				Mongodb
.....................................................................................

What is MongoDb?
   Mongodb is one of the database.

Software structures:

1.Front End- User interface
   Web based /Browser based User interface - React
   Mobile apps 
   Desktop apps
   Device apps
2.Back end - Distributed application
    Application which is connected over network(local,internet)
  Distributed apps are built using two methodology
  1.Monolithic - Express.js,Node.js
  2.Microservices - Nest.js 

3.Data sources- Databases,storage
    Databases:
        DBMS
        RDBMS
        NOSQL

.....................................................................................
			 Mongodb -NQSQL
.....................................................................................

We have learned

1.What is sql and why not sql
2.History of nosql 
3.Types of nosql databases
  -1.Key-value
  -2.column-family
  -3.Document
  -4.Graph
4.aggregate 
   Object or group of objects which stored into storage
  In Document oriented database Aggregate is "Document".


What is Mongodb?
  Mongodb is one of the Document oriented nosql database.
  Mongodb stores data in the form of documents.
.....................................................................................
			  Core Concepts of Mongodb
.....................................................................................

Database:
........
  In MongoDB, databases hold one or more collections of documents. 
  In Relational Databases hold one or more "database objects" -  tables,views,storedprocedures

Document:
  Mongodb stores data records as BSON document, just like json document but binary repreentation of JSON.

json:
 {
   "key":2,
   "key":"test" 
 }
Bson:
 {
   key:12,
   key:"test"
 }
field:value

In relational databases, "document is eq" to "Row"

In relational databases, "Field/key is eq" to "Column"


Collection:
   Grouping of Documents / collection of Documents.

At core, database is group of "collections" , where as collections are group of documents.

Mongodb is schema less or schema flexiable, Every document is highly independant each other.

eg:

 Collection-test
     {name:'x',age:34} - document-1
     {name:'x',age:45,city:'somecity'} - document-2

What if i want to enforce that every document inside a collection must have same set of key and values?

  Yes, Mongodb provides a feature called "Schema Validation" rules, through which you can achive like tables in relational database.


Unique Identifiers:
...................
  Collection is group of document,you must identify each document for query,update,remove, so mongodb assigns an field called "_id" .

"_id":
 It is a field is added automatically or manually , which values are unique.

if you dont provide, mongo automatically assigns "_id"  and its value.

..................................................................................
			 Getting started with Mongodb
....................................................................................

There are two roles

1.Developer
2.Administorator

As a Mongodb developer what should i know.

1.How to create database
2.How to create collection
3.Collection Processing - CURD operations
4.Indexes
5.Transactions
6.Aggreagtions
7.Data Modeling

....................................................................................
			 Setting up Mongodb
.....................................................................................

There are different ways to setup monogdb

You can create a MongoDB database in the following environments:

1.MongoDB Atlas: The fully managed service for MongoDB deployments in the cloud

2.MongoDB Enterprise: The subscription-based, self-managed version of MongoDB

3.MongoDB Community: The source-available, free-to-use, and self-managed version of MongoDB

4.Mongodb Docker: This is containerized way of setting up mongodb, it is for development and also for production.
...................................................................................

1.MongoDB Atlas:
    The fully managed service for MongoDB deployments in the cloud

2.MongoDB Enterprise: 
    The subscription-based, self-managed version of MongoDB
   MongoDB Enterprise is available for MongoDB Enterprise subscribers and includes several additional features including LDAP authentication, Kerberos authentication, and System Event Auditing.

3.MongoDB Community:
    The source-available, free-to-use, and self-managed version of MongoDB
  Which does not offer many features, like multi node support,tools...


How to install mongodb on windows?

https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-windows/#std-label-install-mdb-community-windows.
https://www.mongodb.com/try/download/community

Community Edition Offers:

1.Database process
  mongod
C:\Program Files\MongoDB\Server\7.0\bin
  It is a primary daemon process for the mongodb system
2.MongodbCompose
    -It is gui tool to manage mongodb.


How to connect to mongodb process?

There are many client tools and programming languages offers drivers to connect.

1.MongodbCompose
2.Mongoshell -https://www.mongodb.com/try/download/shell

How to connect via mongoshell
C:\Users\subu\Downloads\mongosh-2.3.0-win32-x64\bin

Note: you can set this in the environment variable.
so that you can access monogsh command any where.

3.Programming languages
  node.js(js)
  java
  C#/.net
  Python
 etc...

4.Atals cli

....
Testing Mongosh:

>mongosh --help

Connecting to Mongodb:

>mongosh 
Current Mongosh Log ID: 66cc6d4c29183100ae2710bb
Connecting to:          mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+2.3.0
Using MongoDB:          7.0.12
Using Mongosh:          2.3.0

For mongosh info see: https://www.mongodb.com/docs/mongodb-shell/

------
   The server generated these startup warnings when booting
   2024-08-20T18:49:49.704+05:30: Access control is not enabled for the database. Read and write access to data and configuration is unrestricted
------

test>

Here :
 mongodb://127.0.0.1:27017
   |         |          |
 protocal ip(localhost) port (Which is default port)
 
test is default database is selected.      
....................................................................................
	       Storage Engines for self/community Managed Deployments
....................................................................................

The storage engine is the component of the database that is responsible for managing how data is stored both in memory and on disk.
Monodb supports mulitple storage engines, as different storage engines perform differently.

There are two engines:

1.WiredTier Storage engine(default)
2.InMemory Storage Engine
.....................................................................................
			Databases operations


1.List available databases
2.create database


List Db:
test> show dbs;
admin   40.00 KiB
config  72.00 KiB
local   72.00 KiB

Mongodb by default has three databases called "admin", "config", "local".

Create Database:
  
test> use 

switched to db myNewDb
myNewDb> show dbs;
admin    40.00 KiB
config  108.00 KiB
local    72.00 KiB

Here we have created db but it is not visible or listed in the database

   Every Database we create must have one collection.

How to create Collection?

Collection is created using mongosh in two ways

1.using apis
  In mongosh "mongodb" is referenced by the implicit global variable called "db".
  db is represented by "Database" Object
 Database Object has many methods

 db.apiName 

eg:
 db.createCollection("message")

myNewDb> db.createCollection("message")
  here db refers "myNewDb"

eg:

myNewDb> db.createCollection("message")
{ ok: 1 }

myNewDb> show dbs;
admin     40.00 KiB
config   108.00 KiB
local     72.00 KiB
myNewDb    8.00 KiB
myNewDb>

2.When you insert document into collection which is not yet created
.....................................................................................

How to drop database?

myNewDb> db.dropDatabase()
{ ok: 1, dropped: 'myNewDb' }
.....................................................................................
			 Collections
.....................................................................................

How to list collection?

mynewDb> show collections;
test

How to create collection?

mynewDb> db.createCollection("foo")
{ ok: 1 }
mynewDb> db.createCollection("bar")
{ ok: 1 }

mynewDb> show collections;
bar
foo
test
mynewDb>

How to drop collection?

mynewDb> db.foo.drop()
true
mynewDb> show collections;
test
.....................................................................................
			 Documents CURD
....................................................................................

CURD Operations such as create,update,and delete documents.

Create Operations:

Before insert document into collection, we need collection.

There are two ways to create collection

1.create collection
  db.createCollection("foo")
2.during insert operation

 if the collection does not exists,during insert operation, first collection is created then insert begins.

How to insert document?

Note:
 In Mongodb , mongodb offers lot of apis called methods.
 apis are available on database objects

Syntax:
  databaseReference.Dbmethods
  databaseReference.collection.collectionMethods  

There are two basic api to insert document

db.collection.insertOne(document)
  inserts a single document into a collection
db.collection.insertMany(ArrayOfDocuments)
   inserts multiple documents into a collection

Document Structure:
...................
Document structure inspired from json syntax.
{key:value}
[{key:value}]

key is field, value is the actual data we store.

Every document must have key called "_id" and its value can be integer or hexa decimal.

You can supply key with value, if you dont, mongodb automatically insert "_id" with value.

eg:
myDb> db.greeting.insertOne({_id:1,message:'Hello'})
{ acknowledged: true, insertedId: 1 }

Since insertOne is method which returns "another document".

Returned Document contain:
 1.A boolean acknowledged: true if operation ran with write concern or false if write    concern was disabled
 2.A field insertedId with _id value of inserted document.


How to insert another document?

myDb> db.greeting.insertOne({_id:2,message:'Hai'})
{ acknowledged: true, insertedId: 2 }
myDb> db.greeting.insertOne({_id:3,message:'Weclome'})
{ acknowledged: true, insertedId: 3 }

What if  you dont provide _id?
  myDb> db.greeting.insertOne({message:'greet'})
{
  acknowledged: true,
  insertedId: ObjectId('66cda0f414b2342a562710bc')
}

if y dont provide  _id , mongodb inserts _id and its value which is based on some algorthim.

What if you try insert same id for more than one document?

myDb> db.greeting.insertOne({_id:3,message:'Weclome'})
MongoServerError: E11000 duplicate key error collection: myDb.greeting index: _id_ dup key: { _id: 3 }


Data types:
...........

 Mongo represents JSON format, so json has its own data types.

Mongo stores values into database as BSON type system.
https://bsonspec.org/

What is Bson?
BSON, short for Bin­ary JSON, is a bin­ary-en­coded seri­al­iz­a­tion of JSON-like doc­u­ments. Like JSON, BSON sup­ports the em­bed­ding of doc­u­ments and ar­rays with­in oth­er doc­u­ments and ar­rays.

Mongo has implemented Bson types for stroing data,when you retrive data it returns json format.

Mongo supports all json types + extra types


Type  Number  Alias 

Double 1     "double"
String 2     "string"
Object 3     "object"
Array  4     "array"
Binary data 5 "binData"
Undefined 6  "undefined"
ObjectId 7   "objectId"
Boolean 8    "bool"
Date  9       "date"
Null  10     "null"
Regular Expression 11 "regex"
DBPointer  12  "dbPointer"
JavaScript 13 "javascript"
Symbol   14 "symbol"
32-bit integer 16 "int"
Timestamp 17 "timestamp" 
64-bit integer 18 "long"
Decimal128 19 "decimal"
Min key -1 "minKey"
Max key 127 "maxKey"



When you insert document, you can insert with implicit type.

myDb> db.greeting.insertOne({message:'greet'})

Here typeof message is "string"

How to insert document with Explicit Data type?

myDb> db.types.insertOne({ _id:1, value:1})
{ acknowledged: true, insertedId: 1 }

db.types.insertOne({ _id:2, value:1})
db.types.insertOne({_id:3,value:Long("100")})
db.types.insertOne({_id:4,value:1.02})
db.types.insertOne({_id:5,value:Decimal128("1.01")})
db.types.insertOne({_id:ObjectId(),value:new Date()})


What is ObjectId in MongoDB

In MongoDB, every document within a collection contains an “_id” field that uniquely identifies it, serving as the primary key. The default format for this field is the ObjectId, a 12-byte BSON type that ensures uniqueness and embeds useful metadata, such as the creation timestamp.


An ObjectID is a 12-byte Field Of BSON type

The first 4 bytes represent the Unix Timestamp of the document.
The next 3 bytes are the machine ID on which the MongoDB server is running.
The next 2 bytes are of the process ID.
The last Field is 3 bytes used for incrementing the objectid.

Format of ObjectId:

ObjectId(<hexadecimal>)

ObjectId accepts one parameter which is optional Hexadecimal ObjectId in String.

We can give our own ObjectId to the document but it must be unique.

Key Characteristics of MongoDB ObjectId:
.........................................

Uniqueness: Ensures each document has a unique identifier within a collection.

Timestamp: Embeds a timestamp, allowing you to extract the creation time of the document.

Efficiency: Provides a compact, efficient way to generate unique identifiers without requiring coordination across servers.

Date
mongosh provides various methods to return the date, either as a string or as a Date object:

Date() method which returns the current date as a string.

new Date() constructor which returns a Date object using the ISODate() wrapper.

new ISODate() constructor which returns a Date object using the ISODate() wrapper.
.....................................................................................
			How to insert Multiple documents 
.....................................................................................

db.collection.insertMany([{},{},{}])

myDb> db.names.insertMany([
... {name:'Subramaian'},
... {name:'Murugan'},
... {name:'Karthik'}
... ]
... )
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId('66cda8be14b2342a562710bf'),
    '1': ObjectId('66cda8be14b2342a562710c0'),
    '2': ObjectId('66cda8be14b2342a562710c1')
  }
}
.....................................................................................
			    Value Types
.....................................................................................

Core Value types:

1.numbers - int,long,double,decimal
2.strings  - string
3.boolean - true or false

Object value Types:

1.Object - js literal object syntax - {} - Embeded Document/Nested Document
2.Date

Arrays Value Types

1.Array with primtive values
2.Array with objects


eg: Core types:
myDb> db.coretypes.insertOne({ value1:1,value2:'str',value3:true})
{
  acknowledged: true,
  insertedId: ObjectId('66cdaa0c14b2342a562710c2')
}

eg: Embeded Object/Nested Object:

myDb> db.customers.insertOne({
... name:'Subramanian',
... address:{
... city:'coimbatore',
... state:'Tamil Nadu'
... }
... })
{
  acknowledged: true,
  insertedId: ObjectId('66cdaaec14b2342a562710c3')
}

eg: Primitive Array
myDb> db.employees.insertOne({
... name:'Subramanian',
... skills:[
... 'java',
... 'mongo',
... 'nodejs'
... ]
... })
{
  acknowledged: true,
  insertedId: ObjectId('66cdab7d14b2342a562710c4')ction: myDb.types index: _id_ dup key: { _id: 1 }
}

eg: Complex Array

myDb> db.orders.insertOne({
... name:'p1',
... products:[ {pid:1,pname:'p2'},
... {pid:2,pname:'p3'}
... ]})
{
  acknowledged: true,
  insertedId: ObjectId('66cdac0714b2342a562710c5')
}
....................................................................................
			     Query
....................................................................................

Insert some Mock data:
....................
db.inventory.insertMany([
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);

How to read documents from the collection?

syntax:
 db.collection.find(query,projection,options)

query
  selectional filter using query operators -  optional

projection
  specifies the fields to return in the documents,fields formating

options
   specifies the options which change query behaviour and how results are returned

InSQL:
  SELECT *FROM tableName;

eg:
 myDb> db.inventory.find()
[
  {
    _id: ObjectId('66cdb31214b2342a562710c6'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710c7'),
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710c8'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  }
]

myDb> db.inventory.find({})
[
  {
    _id: ObjectId('66cdb31214b2342a562710c6'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710c7'),
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710c8'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  }
]
.....................................................................................
			Specify Equality Condition
...................................................................................

To specify equality condition, use <field:<value> expressions in the query filter document.

myDb> db.inventory.find({status:"D"})
[
  {
    _id: ObjectId('66cdb31214b2342a562710c8'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710c9'),
    item: 'planner',
    qty: 75,
    size: { h: 22.85, w: 30, uom: 'cm' },
    status: 'D'
  }
]

IN sql:
 SELECT *FROM inventory WHERE status="D"

More fields:
................

myDb> db.inventory.find({status:"D",item:'paper'})
[
  {
    _id: ObjectId('66cdb31214b2342a562710c8'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  }
]

IN sql:
 SELECT *FROM inventory WHERE status="D" AND item="Paper"
.....................................................................................
			Operators
.....................................................................................

In mongodb operators are classifed into various category

1.comparsion Operators
2.Logical Operators
3.Element operators
4.Array operators
5.Project operators
6.other operators

Note:
 All operators are behind the mongo is just functions only.
 All operators are represented by "$operatorName"

eg:
 $eq
 $gt
 $lt

Comparison
...........

$eq
Matches values that are equal to a specified value.

$gt
Matches values that are greater than a specified value.

$gte
Matches values that are greater than or equal to a specified value.

$in
Matches any of the values specified in an array.

$lt
Matches values that are less than a specified value.

$lte
Matches values that are less than or equal to a specified value.

$ne
Matches all values that are not equal to a specified value.

$nin
Matches none of the values specified in an array.

Logical
........

$and
Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.

$not
Inverts the effect of a query expression and returns documents that do not match the query expression.

$nor
Joins query clauses with a logical NOR returns all documents that fail to match both clauses.

$or
Joins query clauses with a logical OR returns all documents that match the conditions of either clause.

Element:
........
$exists
Matches documents that have the specified field.
$type
Selects documents if a field is of the specified type.

Array
......
$all
Matches arrays that contain all elements specified in the query.

$elemMatch
Selects documents if element in the array field matches all the specified $elemMatch conditions.

$size
Selects documents if the array field is a specified size.

Projection Operators
.......................
$
Projects the first element in an array that matches the query condition.

$elemMatch
Projects the first element in an array that matches the specified $elemMatch condition.

$meta
Projects the document's score assigned during the $text operation.

Miscellaneous Operators

$comment
Adds a comment to a query predicate.
$rand
Generates a random float between 0 and 1.

.....................................................................................
How to select documents based on based operators

Selection Using Operators:
..........................

{ <field1>: { <operator1>: <value1> }, ... }

The following example retrieves all documents from the inventory collection where status equals either "A" or "D":

myDb> db.inventory.find({ status: { $in: ["A", "D"] } })
[
  {
    _id: ObjectId('66cdb31214b2342a562710c6'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710c7'),
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710c8'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  }
]
The operation uses a filter predicate of { status: { $in: [ "A", "D" ] } }, which corresponds to the following SQL statement:

SELECT * FROM inventory WHERE status in ("A", "D")
....................................................................................
Specify AND Conditions

A compound query can specify conditions for more than one field in the collection's 
documents. Implicitly, a logical AND conjunction connects the clauses of a compound query so that the query selects the documents in the collection that match all the conditions.

The following example retrieves all documents in the inventory collection where the status equals "A" and qty is less than ($lt) 30:


myDb> db.inventory.find({
... status:"A",
... qty:{$lt:30}
... }
... )
[
  {
    _id: ObjectId('66cdb31214b2342a562710c6'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  }
]

The operation uses a filter predicate of { status: "A", qty: { $lt: 30 } }, which corresponds to the following SQL statement:

SELECT * FROM inventory WHERE status = "A" AND qty < 30

....................................................................................
Specify OR Conditions
Using the $or operator, you can specify a compound query that joins each clause with a logical OR conjunction so that the query selects the documents in the collection that match at least one condition.

The following example retrieves all documents in the collection where the status equals "A" or qty is less than ($lt) 30:


The operation uses a filter predicate of { $or: [ { status: 'A' }, { qty: { $lt: 30 } } ] }, which corresponds to the following SQL statement:

SELECT * FROM inventory WHERE status = "A" OR qty < 30

myDb> db.inventory.find({ $or: [{status: "A"}, {qty: { $lt: 30 }} ] } )
[
  {
    _id: ObjectId('66cdb31214b2342a562710c6'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710c7'),
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710ca'),
    item: 'postcard',
    qty: 45,
    size: { h: 10, w: 15.25, uom: 'cm' },
    status: 'A'
  }
]
....................................................................................
Specify AND as well as OR Conditions

In the following example, the compound query document selects all documents in the collection where the status equals "A" and either qty is less than ($lt) 30 or item starts with the character p.

myDb> db.inventory.find({
... status:"A",
... $or:[
... {qty: {$lt:30}},
... {item:/^p/} ]
... })
[
  {
    _id: ObjectId('66cdb31214b2342a562710c6'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710ca'),
    item: 'postcard',
    qty: 45,
    size: { h: 10, w: 15.25, uom: 'cm' },
    status: 'A'
  }
]

Using Regular expression Data type:
....................................
myDb> db.inventory.find({ status: "A", $or: [ { qty: { $lt: 30 } }, { item: {$regex:'^p'} }] })
[
  {
    _id: ObjectId('66cdb31214b2342a562710c6'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cdb31214b2342a562710ca'),
    item: 'postcard',
    qty: 45,
    size: { h: 10, w: 15.25, uom: 'cm' },
    status: 'A'
  }
]
....................................................................................
			   Projection
...................................................................................

Projection means, control field informations.

1.include and exculde fields
2.adding extra fields which is not there in the original collection
3.data formating.

1.Include and Exclude

 Generally all fields are returned as part of result.

 db.collection.find({},{field1:Value,field2:value})

 field1: <1 or true>
   It means the inclusion of a field,you can specify any non-zero value for projection.

 field1: <0 or false>
 It means the exclusion of a field

Use Case: Exculde _id

myDb> db.inventory.find({},{"_id":0})
[
  {
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  }
]

How to exclude other fields:
...........................
myDb> db.inventory.find({},{"_id":0,size:0})
[
  { item: 'journal', qty: 25, status: 'A' },
  { item: 'notebook', qty: 50, status: 'A' },
  { item: 'paper', qty: 100, status: 'D' }
]

Rules For Inclusion or Exclusion
.................................

A projection cannot contain both include and exclude specifications, with the exception of the _id field:

In projections that explicitly include fields, the _id field is the only field that you can explicitly exclude.

In projections that explicitly excludes fields, the _id field is the only field that you can explicitly include; however, the _id field is included by default.
.....................................................................................

	Adding extra fields which is not there in the original collection
			data formating


Before that have some mock data:

db.bios.insertMany([
   {
       "_id" : 1,
       "name" : {
           "first" : "John",
           "last" : "Backus"
       },
       "birth" : ISODate("1924-12-03T05:00:00Z"),
       "death" : ISODate("2007-03-17T04:00:00Z"),
       "contribs" : [
           "Fortran",
           "ALGOL",
           "Backus-Naur Form",
           "FP"
       ],
       "awards" : [
           {
               "award" : "W.W. McDowell Award",
               "year" : 1967,
               "by" : "IEEE Computer Society"
           },
           {
               "award" : "National Medal of Science",
               "year" : 1975,
               "by" : "National Science Foundation"
           },
           {
               "award" : "Turing Award",
               "year" : 1977,
               "by" : "ACM"
           },
           {
               "award" : "Draper Prize",
               "year" : 1993,
               "by" : "National Academy of Engineering"
           }
       ]
   },
   {
       "_id" : ObjectId("51df07b094c6acd67e492f41"),
       "name" : {
           "first" : "John",
           "last" : "McCarthy"
       },
       "birth" : ISODate("1927-09-04T04:00:00Z"),
       "death" : ISODate("2011-12-24T05:00:00Z"),
       "contribs" : [
           "Lisp",
           "Artificial Intelligence",
           "ALGOL"
       ],
       "awards" : [
           {
               "award" : "Turing Award",
               "year" : 1971,
               "by" : "ACM"
           },
           {
               "award" : "Kyoto Prize",
               "year" : 1988,
               "by" : "Inamori Foundation"
           },
           {
               "award" : "National Medal of Science",
               "year" : 1990,
               "by" : "National Science Foundation"
           }
       ]
   },
   {
       "_id" : 3,
       "name" : {
           "first" : "Grace",
           "last" : "Hopper"
       },
       "title" : "Rear Admiral",
       "birth" : ISODate("1906-12-09T05:00:00Z"),
       "death" : ISODate("1992-01-01T05:00:00Z"),
       "contribs" : [
           "UNIVAC",
           "compiler",
           "FLOW-MATIC",
           "COBOL"
       ],
       "awards" : [
           {
               "award" : "Computer Sciences Man of the Year",
               "year" : 1969,
               "by" : "Data Processing Management Association"
           },
           {
               "award" : "Distinguished Fellow",
               "year" : 1973,
               "by" : " British Computer Society"
           },
           {
               "award" : "W. W. McDowell Award",
               "year" : 1976,
               "by" : "IEEE Computer Society"
           },
           {
               "award" : "National Medal of Technology",
               "year" : 1991,
               "by" : "United States"
           }
       ]
   },
   {
       "_id" : 4,
       "name" : {
           "first" : "Kristen",
           "last" : "Nygaard"
       },
       "birth" : ISODate("1926-08-27T04:00:00Z"),
       "death" : ISODate("2002-08-10T04:00:00Z"),
       "contribs" : [
           "OOP",
           "Simula"
       ],
       "awards" : [
           {
               "award" : "Rosing Prize",
               "year" : 1999,
               "by" : "Norwegian Data Association"
           },
           {
               "award" : "Turing Award",
               "year" : 2001,
               "by" : "ACM"
           },
           {
               "award" : "IEEE John von Neumann Medal",
               "year" : 2001,
               "by" : "IEEE"
           }
       ]
   },
   {
       "_id" : 5,
       "name" : {
           "first" : "Ole-Johan",
           "last" : "Dahl"
       },
       "birth" : ISODate("1931-10-12T04:00:00Z"),
       "death" : ISODate("2002-06-29T04:00:00Z"),
       "contribs" : [
           "OOP",
           "Simula"
       ],
       "awards" : [
           {
               "award" : "Rosing Prize",
               "year" : 1999,
               "by" : "Norwegian Data Association"
           },
           {
               "award" : "Turing Award",
               "year" : 2001,
               "by" : "ACM"
           },
           {
               "award" : "IEEE John von Neumann Medal",
               "year" : 2001,
               "by" : "IEEE"
           }
       ]
   },
   {
       "_id" : 6,
       "name" : {
           "first" : "Guido",
           "last" : "van Rossum"
       },
       "birth" : ISODate("1956-01-31T05:00:00Z"),
       "contribs" : [
           "Python"
       ],
       "awards" : [
           {
               "award" : "Award for the Advancement of Free Software",
               "year" : 2001,
               "by" : "Free Software Foundation"
           },
           {
               "award" : "NLUUG Award",
               "year" : 2003,
               "by" : "NLUUG"
           }
       ]
   },
   {
       "_id" : ObjectId("51e062189c6ae665454e301d"),
       "name" : {
           "first" : "Dennis",
           "last" : "Ritchie"
       },
       "birth" : ISODate("1941-09-09T04:00:00Z"),
       "death" : ISODate("2011-10-12T04:00:00Z"),
       "contribs" : [
           "UNIX",
           "C"
       ],
       "awards" : [
           {
               "award" : "Turing Award",
               "year" : 1983,
               "by" : "ACM"
           },
           {
               "award" : "National Medal of Technology",
               "year" : 1998,
               "by" : "United States"
           },
           {
               "award" : "Japan Prize",
               "year" : 2011,
               "by" : "The Japan Prize Foundation"
           }
       ]
   },
   {
       "_id" : 8,
       "name" : {
           "first" : "Yukihiro",
           "aka" : "Matz",
           "last" : "Matsumoto"
       },
       "birth" : ISODate("1965-04-14T04:00:00Z"),
       "contribs" : [
           "Ruby"
       ],
       "awards" : [
           {
               "award" : "Award for the Advancement of Free Software",
               "year" : "2011",
               "by" : "Free Software Foundation"
           }
       ]
   },
   {
       "_id" : 9,
       "name" : {
           "first" : "James",
           "last" : "Gosling"
       },
       "birth" : ISODate("1955-05-19T04:00:00Z"),
       "contribs" : [
           "Java"
       ],
       "awards" : [
           {
               "award" : "The Economist Innovation Award",
               "year" : 2002,
               "by" : "The Economist"
           },
           {
               "award" : "Officer of the Order of Canada",
               "year" : 2007,
               "by" : "Canada"
           }
       ]
   },
   {
       "_id" : 10,
       "name" : {
           "first" : "Martin",
           "last" : "Odersky"
       },
       "contribs" : [
           "Scala"
       ]
   }

] )
...

Projection:

myDb> db.bios.find({},{name:1,contribs:1})
[
  {
    _id: 1,
    name: { first: 'John', last: 'Backus' },
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ]
  },
  {
    _id: ObjectId('51df07b094c6acd67e492f41'),
    name: { first: 'John', last: 'McCarthy' },
    contribs: [ 'Lisp', 'Artificial Intelligence', 'ALGOL' ]
  },
  {
    _id: 3,
    name: { first: 'Grace', last: 'Hopper' },
    contribs: [ 'UNIVAC', 'compiler', 'FLOW-MATIC', 'COBOL' ]
  }
]


Use Aggregation Expression
...........................

db.collection.find() projection can accept aggregation expressions and syntax.

 With the use of aggregation expressions and syntax, you can project new fields or project existing fields with new values.

 For example, the following operation uses aggregation expressions to override the value of the name and awards fields as well as to include new fields reportDate, reportBy, and reportNumber.


eg:
myDb> db.bios.find(
...    { },
...    {
...      _id: 0,
...      name: {
...         $concat: [
...            { $ifNull: [ "$name.aka", "$name.first" ] },
...            " ",
...            "$name.last"
...         ]
...      },
...      birth: 1,
...      contribs: 1,
...      awards: { $cond: { if: { $isArray: "$awards" }, then: { $size: "$awards" }, else: 0 } },
...      reportDate: { $dateToString: {  date: new Date(), format: "%Y-%m-%d" } },
...      reportBy: "subu",
...      reportNumber: { $literal: 1 }
...    }
... )
[
  {
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    name: 'John Backus',
    awards: 4,
    reportDate: '2024-08-27',
    reportBy: 'subu',
    reportNumber: 1
  },
  {
    birth: ISODate('1927-09-04T04:00:00.000Z'),277)$ifNull:["$name.aka","$name.first"] },"","$name.last" ] }, birth:1, contribs:1, awar
    contribs: [ 'Lisp', 'Artificial Intelligence', 'ALGOL' ],},else:0}}, reportDate:{$dateToString: {date:new Date()},format:'%Y-%m-%d'
    name: 'John McCarthy',id:0, name:{ $concat: [ {$ifNull:["$name.aka","$name.first"] },"","$name.last" ] }, birth:1, contribs:1, awar
    awards: 3,$if: {$isArray:"$awards"},then:{$size:"$awards"},else:0}}, reportDate:{$dateToString: {date:new Date()},format:'%Y-%m-%d'
    reportDate: '2024-08-27',eportNumber:222} } cls
    reportBy: 'subu',
    reportNumber: 1
  },         ^
  { |
    birth: ISODate('1906-12-09T05:00:00.000Z'),
    contribs: [ 'UNIVAC', 'compiler', 'FLOW-MATIC', 'COBOL' ],
    name: 'Grace Hopper',
    awards: 4,
    reportDate: '2024-08-27',
    reportBy: 'subu',
    reportNumber: 1
  }
]
.....................................................................................
				Cursors
....................................................................................
In MongoDB, a cursor is a pointer to the result set of a query. When you execute a find operation, MongoDB returns a cursor that allows you to iterate over the documents in the result set. 

In mongosh, if the returned cursor is not assigned to a variable using the var keyword, the cursor is automatically iterated to access up to the first 20 documents that match the query. You can update the displayBatchSize variable to change the number of automatically iterated documents.

The default cursor size is 20, meaning that find mongosh, returns only 20 records at time , beyond 20 documents, then automatically it adds currsor reference.

How to control cursor size or  i want to show only few documents at a time?

myDb> config.set("displayBatchSize",3)
Setting "displayBatchSize" has been changed


myDb> db.bios.find()
[
  {
    _id: 1,
    name: { first: 'John', last: 'Backus' },
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    death: ISODate('2007-03-17T04:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    awards: [
      {
        award: 'W.W. McDowell Award',
        year: 1967,
        by: 'IEEE Computer Society'
      },
      {
        award: 'National Medal of Science',
        year: 1975,
        by: 'National Science Foundation'
      },
      { award: 'Turing Award', year: 1977, by: 'ACM' },
      {
        award: 'Draper Prize',
        year: 1993,
        by: 'National Academy of Engineering'
      }
    ]
  },
  {
    _id: ObjectId('51df07b094c6acd67e492f41'),
    name: { first: 'John', last: 'McCarthy' },
    birth: ISODate('1927-09-04T04:00:00.000Z'),
    death: ISODate('2011-12-24T05:00:00.000Z'),
    contribs: [ 'Lisp', 'Artificial Intelligence', 'ALGOL' ],
    awards: [
      { award: 'Turing Award', year: 1971, by: 'ACM' },
      { award: 'Kyoto Prize', year: 1988, by: 'Inamori Foundation' },
      {
        award: 'National Medal of Science',
        year: 1990,
        by: 'National Science Foundation'
      }
    ]
  },
  {
    _id: 3,

Type "it" for more
.....................................................................................
		How to assign the result of find into variable
....................................................................................

var Mycursor = db.bios.find({})

myDb> var Mycursor = db.bios.find({})

myDb> Mycursor
[
  {
    _id: 1,
    name: { first: 'John', last: 'Backus' },
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    death: ISODate('2007-03-17T04:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    awards: [
      {
        award: 'W.W. McDowell Award',
        year: 1967,
        by: 'IEEE Computer Society'
      },
      {
        award: 'National Medal of Science',
        year: 1975,
        by: 'National Science Foundation'
      },
      { award: 'Turing Award', year: 1977, by: 'ACM' },
      {
        award: 'Draper Prize',
        year: 1993,
        by: 'National Academy of Engineering'
      }
    ]
  }
]

via program how to access cursor
while(Mycursor.hasNext()){
  print(tojson(Mycursor.next());
}
....................................................................................
				Cursor Methods
....................................................................................

Since Cursor Object, which has lot of methods.

cursor.limit(n) - Limits the number of document returned
cursor.sort({field:1})- sorts the document based on field
cursor.skip(n) - skips the first n documents
cursor.count() - counts the no of documents
etc..

myDb> db.bios.find({}).limit(2)
[
  {
    _id: 1,
    name: { first: 'John', last: 'Backus' },
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    death: ISODate('2007-03-17T04:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    awards: [
      {
        award: 'W.W. McDowell Award',
        year: 1967,
        by: 'IEEE Computer Society'
      },
      {
        award: 'National Medal of Science',
        year: 1975,
        by: 'National Science Foundation'
      },
      { award: 'Turing Award', year: 1977, by: 'ACM' },
myDb>
        award: 'Draper Prize',
        year: 1993,
        by: 'National Academy of Engineering'
      }
    ]
  },
  {
    _id: ObjectId('51df07b094c6acd67e492f41'),
    name: { first: 'John', last: 'McCarthy' },
    birth: ISODate('1927-09-04T04:00:00.000Z'),
    death: ISODate('2011-12-24T05:00:00.000Z'),
    contribs: [ 'Lisp', 'Artificial Intelligence', 'ALGOL' ],
    awards: [
      { award: 'Turing Award', year: 1971, by: 'ACM' },
      { award: 'Kyoto Prize', year: 1988, by: 'Inamori Foundation' },
      {
        award: 'National Medal of Science',
        year: 1990,
        by: 'National Science Foundation'
      }
    ]
  }
]

You can coimbine multiple methods in chain.

myDb> db.bios.find({}).limit(5).sort({birth:1})
[
  {
    _id: 10,
    name: { first: 'Martin', last: 'Odersky' },
    contribs: [ 'Scala' ]
  },
  {
    _id: 3,
    name: { first: 'Grace', last: 'Hopper' },
    title: 'Rear Admiral',
    birth: ISODate('1906-12-09T05:00:00.000Z'),
    death: ISODate('1992-01-01T05:00:00.000Z'),
    contribs: [ 'UNIVAC', 'compiler', 'FLOW-MATIC', 'COBOL' ],
    awards: [
      {
        award: 'Computer Sciences Man of the Year',
        year: 1969,
        by: 'Data Processing Management Association'
      },
      {
        award: 'Distinguished Fellow',
        year: 1973,
        by: ' British Computer Society'
      },
      {
        award: 'W. W. McDowell Award',
        year: 1976,
        by: 'IEEE Computer Society'
      },
      {
        award: 'National Medal of Technology',
        year: 1991,
        by: 'United States'
      }
    ]
  },
  {
    _id: 1,
    name: { first: 'John', last: 'Backus' },
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    death: ISODate('2007-03-17T04:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    awards: [
      {
        award: 'W.W. McDowell Award',
        year: 1967,
        by: 'IEEE Computer Society'
      },
      {
        award: 'National Medal of Science',
        year: 1975,
        by: 'National Science Foundation'
      },
      { award: 'Turing Award', year: 1977, by: 'ACM' },
      {
        award: 'Draper Prize',
        year: 1993,
        by: 'National Academy of Engineering'
      }
    ]
  },
  {
    _id: 4,
    name: { first: 'Kristen', last: 'Nygaard' },
    birth: ISODate('1926-08-27T04:00:00.000Z'),
    death: ISODate('2002-08-10T04:00:00.000Z'),
    contribs: [ 'OOP', 'Simula' ],
    awards: [
      {
        award: 'Rosing Prize',
        year: 1999,
        by: 'Norwegian Data Association'
      },
      { award: 'Turing Award', year: 2001, by: 'ACM' },
      { award: 'IEEE John von Neumann Medal', year: 2001, by: 'IEEE' }
    ]
  },
  {
    _id: ObjectId('51df07b094c6acd67e492f41'),
    name: { first: 'John', last: 'McCarthy' },
    birth: ISODate('1927-09-04T04:00:00.000Z'),
    death: ISODate('2011-12-24T05:00:00.000Z'),
    contribs: [ 'Lisp', 'Artificial Intelligence', 'ALGOL' ],
    awards: [
      { award: 'Turing Award', year: 1971, by: 'ACM' },
      { award: 'Kyoto Prize', year: 1988, by: 'Inamori Foundation' },
      {
        award: 'National Medal of Science',
        year: 1990,
        by: 'National Science Foundation'
      }
    ]
  }
]
....................................................................................
			Query on Embeded/Nested Documents
....................................................................................

Mock Data:
db.inventory.insertMany( [
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   ])

I want to return documents based on size and uom.

myDb> db.inventory.find({"size.uom":"in"})
[
  {
    _id: ObjectId('66cef216ffea971f1d2710bd'),
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    _id: ObjectId('66cef216ffea971f1d2710be'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  }
]
myDb>

Query on Nested field with "Dot Notation":
..........................................

To specify a query condition on fields in an embedded/nested document, use dot notation ("field.nestedField").

Note
When querying using dot notation, the field and nested field must be inside quotation marks.

Specify Match using Query Operator
....................................

A query filter document can use the query operators to specify conditions in the following form:

{ <field1>: { <operator1>: <value1> }, ... }

The following query uses the less than operator ($lt) on the field h embedded in the size field:

myDb> db.inventory.find({"size.h":{$lt:15}}
... )
[
  {
    _id: ObjectId('66cef216ffea971f1d2710bc'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cef216ffea971f1d2710bd'),
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    _id: ObjectId('66cef216ffea971f1d2710be'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  }
]

Specify AND Condition
........................
The following query selects all documents where the nested field h is less than 15, the nested field uom equals "in", and the status field equals "D"

myDb> db.inventory.find( { "size.h": { $lt: 15 }, "size.uom": "in", status: "D" } )
[
  {
    _id: ObjectId('66cef216ffea971f1d2710be'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  }
]
...................................................................................
Warning:

  MongoDB does not recommend comparisons on embedded documents because the operations require an exact match of the specified <value> document, including the field order.

For example, the following query does not match any documents in the inventory collection:

db.inventory.find(  { size: { w: 21, h: 14, uom: "cm" } }  )


Queries that use comparisons on embedded documents can result in unpredictable behavior when used with a driver that does not use ordered data structures for expressing queries.
....................................................................................
			   Projections and Nested Documents
....................................................................................

Use case:
 I dont want to show first Name.

myDb> db.bios.find({},{name:{first:0}}).limit(1)
[
  {
    _id: 1,
    name: { last: 'Backus' },
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    death: ISODate('2007-03-17T04:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    awards: [
      {
        award: 'W.W. McDowell Award',
        year: 1967,
        by: 'IEEE Computer Society'
      },
      {
        award: 'National Medal of Science',
        year: 1975,
        by: 'National Science Foundation'
      },
      { award: 'Turing Award', year: 1977, by: 'ACM' },
      {
        award: 'Draper Prize',
        year: 1993,
        by: 'National Academy of Engineering'
      }
    ]
  }
]
...................................................................................
			 Query Data based on Nested Array
...................................................................................

Mock data:

db.inventory.insertMany([
   { item: "journal", qty: 25, tags: ["blank", "red"], dim_cm: [ 14, 21 ] },
   { item: "notebook", qty: 50, tags: ["red", "blank"], dim_cm: [ 14, 21 ] },
   { item: "paper", qty: 100, tags: ["red", "blank", "plain"], dim_cm: [ 14, 21 ] },
   { item: "planner", qty: 75, tags: ["blank", "red"], dim_cm: [ 22.85, 30 ] },
   { item: "postcard", qty: 45, tags: ["blue"], dim_cm: [ 10, 15.25 ] }
]);

To specify equality condition on an array, use the query document 
{ <field>: <value> } where <value> is the exact array to match, including the order of the elements.

The following example queries for all documents where the field tags value is an array with exactly two elements, "red" and "blank", in the specified order:

myDb> db.inventory.find({tags:["red","blank"]})
[
  {
    _id: ObjectId('66cef77affea971f1d2710c0'),
    item: 'notebook',
    qty: 50,
    tags: [ 'red', 'blank' ],
    dim_cm: [ 14, 21 ]
  }
]
.....................................................................................
				$all Operator
......................................................................................
If, instead, you wish to find an array that contains both the elements "red" and "blank", without regard to order or other elements in the array, use the $all operator:

db.inventory.find( { tags: { $all: ["red", "blank"] } } )

myDb> db.inventory.find({tags:{$all:["red","blank"]}})
[
  {
    _id: ObjectId('66cef77affea971f1d2710bf'),
    item: 'journal',
    qty: 25,
    tags: [ 'blank', 'red' ],
    dim_cm: [ 14, 21 ]
  },
  {
    _id: ObjectId('66cef77affea971f1d2710c0'),
    item: 'notebook',
    qty: 50,
    tags: [ 'red', 'blank' ],
    dim_cm: [ 14, 21 ]
  },
  {
    _id: ObjectId('66cef77affea971f1d2710c1'),
    item: 'paper',
    qty: 100,
    tags: [ 'red', 'blank', 'plain' ],
    dim_cm: [ 14, 21 ]
  },
  {
    _id: ObjectId('66cef77affea971f1d2710c2'),
    item: 'planner',
    qty: 75,
    tags: [ 'blank', 'red' ],
    dim_cm: [ 22.85, 30 ]
  }
]
.....................................................................................
			  Conditional Operators on Array elements
.....................................................................................

To specify conditions on the elements in the array field, use query operators in the query filter document:

{ <array field>: { <operator1>: <value1>, ... } }


For example, the following operation queries for all documents where the array dim_cm contains at least one element whose value is greater than 25.

myDb> db.inventory.find({dim_cm:{$gt:25}})
[
  {
    _id: ObjectId('66cef77affea971f1d2710c2'),
    item: 'planner',
    qty: 75,
    tags: [ 'blank', 'red' ],
    dim_cm: [ 22.85, 30 ]
  }
]
....................................................................................
		    Query Based On Array length
			  $size
...................................................................................
Use the $size operator to query for arrays by number of elements. For example, the following selects documents where the array tags has 3 elements.

myDb> db.inventory.find( { "tags": { $size: 3 } } )
[
  {
    _id: ObjectId('66cef77affea971f1d2710c1'),
    item: 'paper',
    qty: 100,
    tags: [ 'red', 'blank', 'plain' ],
    dim_cm: [ 14, 21 ]
  }
]
....................................................................................
		Query for an Element by the Array Index Position
..................................................................................

Using dot notation, you can specify query conditions for an element at a particular index or position of the array. The array uses zero-based indexing.

Note
When querying using dot notation, the field and nested field must be inside quotation marks.

The following example queries for all documents where the second element in the array dim_cm is greater than 25:

db.inventory.find( { "dim_cm.1": { $gt: 25 } } )
		
Here "dim_cm" is key, where . is spearator 1 is arrayIndex

myDb> db.inventory.find( { "dim_cm.1": { $gt: 25 } } )
[
  {
    _id: ObjectId('66cef77affea971f1d2710c2'),
    item: 'planner',
    qty: 75,
    tags: [ 'blank', 'red' ],
    dim_cm: [ 22.85, 30 ]
  }
]

.....................................................................................
As of how we have searched documents of nested array with primitve values like numbers and strings.

 	Query An Array of Nested Objects(Documents)/Embeded Documents
.....................................................................................
Mock data:
db.inventory.insertMany( [
   { item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] },
   { item: "notebook", instock: [ { warehouse: "C", qty: 5 } ] },
   { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 15 } ] },
   { item: "planner", instock: [ { warehouse: "A", qty: 40 }, { warehouse: "B", qty: 5 } ] },
   { item: "postcard", instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }
]);

The following example selects all documents where an element in the instock array matches the specified document:

myDb>  db.inventory.find({"instock": {warehouse:"A",qty:5}})
[
  {
    _id: ObjectId('66cefb91ffea971f1d2710c4'),
    item: 'journal',
    instock: [ { warehouse: 'A', qty: 5 }, { warehouse: 'C', qty: 15 } ]
  }
]

Equality matches on the whole embedded/nested document require an exact match of the specified document, including the field order. For example, the following query does not match any documents in the inventory collection:

db.inventory.find( { "instock": { qty: 5, warehouse: "A" } } )


Conditional:
............
Specify a Query Condition on a Field in an Array of Documents:
..............................................................

Specify a Query Condition on a Field Embedded in an Array of Documents
If you do not know the index position of the document nested in the array, concatenate the name of the array field, with a dot (.) and the name of the field in the nested document.

The following example selects all documents where the instock array has at least one embedded document that contains the field qty whose value is less than or equal to 20:

db.inventory.find( { 'instock.qty': { $lte: 20 } } )

db.inventory.find( { "instock.qty": 5, "instock.warehouse": "A" } )

db.inventory.find( { "instock.qty": { $gt: 10,  $lte: 20 } } )


eg:
myDb> db.inventory.find( { 'instock.qty': { $lte: 20 } } )
[
  {
    _id: ObjectId('66cefb91ffea971f1d2710c4'),
    item: 'journal',
    instock: [ { warehouse: 'A', qty: 5 }, { warehouse: 'C', qty: 15 } ]
  },
  {
    _id: ObjectId('66cefb91ffea971f1d2710c5'),
    item: 'notebook',
    instock: [ { warehouse: 'C', qty: 5 } ]
  },
  {
    _id: ObjectId('66cefb91ffea971f1d2710c6'),
    item: 'paper',
    instock: [ { warehouse: 'A', qty: 60 }, { warehouse: 'B', qty: 15 } ]
  },
  {
    _id: ObjectId('66cefb91ffea971f1d2710c7'),
    item: 'planner',
    instock: [ { warehouse: 'A', qty: 40 }, { warehouse: 'B', qty: 5 } ]
  },
  {
    _id: ObjectId('66cefb91ffea971f1d2710c8'),
    item: 'postcard',
    instock: [ { warehouse: 'B', qty: 15 }, { warehouse: 'C', qty: 35 } ]
  }
]
.....................................................................................
			 Null Values and Missing Fields
....................................................................................

How to insert null values? and query null value?

myDb> db.nullcol.insertMany([
... {_id:1,item:null},
... {_id:2},
... ])
{ acknowledged: true, insertedIds: { '0': 1, '1': 2 } }

Equality Filter
   The { item : null } query matches documents that either contain the item field whose value is null or that do not contain the item field.

myDb> db.nullcol.find({item:null})
[ { _id: 1, item: null }, { _id: 2 } ]
myDb>


The query returns both documents in the collection.

Non-Equality Filter:
....................

To query for fields that exist and are not null, use the { $ne : null } filter. 

The { item : { $ne : null } } query matches documents where the item field exists and has a non-null value.

myDb> db.nullcol.insertOne({_id:3,item:'phone'})
{ acknowledged: true, insertedId: 3 }
myDb> db.nullcol.find({ item : { $ne : null } })
[ { _id: 3, item: 'phone' } ]
myDb>
..........................................................

Type and Existence Checking:
...........................
Type Check
...........
 $type operator to check type of value

The { item : { $type: 10 } } query matches only documents that contain the item field whose value is null; i.e. the value of the item field is of BSON Type Null (BSON Type 10):

myDb> db.nullcol.find( { item : { $type: 10 } } )
[ { _id: 1, item: null } ]

Existence Check
...............
  $exits Operator

The following example queries for documents that do not contain a field.

The { item : { $exists: false } } query matches documents that do not contain the item field:

myDb> db.nullcol.find( { item : { $exists: false } } )
[ { _id: 2 } ]
.....................................................................................
			   Indexes
.....................................................................................

Purpose of Indexes:

Indexes allow efficient querying and retrieval of documents from a collection.

Without indexes, MongoDB would need to scan every document in a collection to return query results.

When an appropriate index exists for a query, MongoDB uses it to limit the number of documents it must scan.

Indexes in MongoDB are special data structures that store a portion of the collection’s data set in an easy-to-traverse form. They play a crucial role in improving query performance by providing quick access to data based on indexed fields


Types of Indexes:

1.Single Field Index: Created on a single field (e.g., employee ID, location).

2.Compound Index: Combines multiple fields (e.g., item and quantity) for more complex   queries.

3.Index on Embedded Documents: Useful when querying entire embedded objects.

4.Geospatial Index: Supports geospatial queries based on location data.

...................................................................................

Eg:

Without Indexing how search operation looks like.
myDb> db.inventory.find({item:'paper'}).explain('executionStats')
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'myDb.inventory',
    indexFilterSet: false,
    parsedQuery: { item: { '$eq': 'paper' } },
    queryHash: '8098DE55',
    planCacheKey: '8098DE55',
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    winningPlan: {
      stage: 'COLLSCAN',
      filter: { item: { '$eq': 'paper' } },
      direction: 'forward'
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 1,
    executionTimeMillis: 0,
    totalKeysExamined: 0,
    totalDocsExamined: 5,
    executionStages: {
      stage: 'COLLSCAN',
      filter: { item: { '$eq': 'paper' } },
      nReturned: 1,
      executionTimeMillisEstimate: 0,
      works: 6,
      advanced: 1,
      needTime: 4,
      needYield: 0,
      saveState: 0,
      restoreState: 0,
      isEOF: 1,
      direction: 'forward',
      docsExamined: 5
    }
  },
  command: { find: 'inventory', filter: { item: 'paper' }, '$db': 'myDb' },
  serverInfo: {
    host: 'DESKTOP-KAUFCR7',
    port: 27017,
    version: '7.0.12',
    gitVersion: 'b6513ce0781db6818e24619e8a461eae90bc94fc'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600,
    internalQueryFrameworkControl: 'trySbeRestricted'
  },
  ok: 1
}
....................................................................................

Create Index:

db.collection.createIndex({item:1 or -1})
1- means ascending order
-1 - means descending order


myDb> db.inventory.createIndex({item:1})
item_1

myDb> db.inventory.find({item:'paper'}).explain('executionStats')
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'myDb.inventory',
    indexFilterSet: false,
    parsedQuery: { item: { '$eq': 'paper' } },
    queryHash: '8098DE55',
    planCacheKey: 'BD68BBA1',
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    winningPlan: {
      stage: 'FETCH',
      inputStage: {
        stage: 'IXSCAN',
        keyPattern: { item: 1 },
        indexName: 'item_1',
        isMultiKey: false,
        multiKeyPaths: { item: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: { item: [ '["paper", "paper"]' ] }
      }
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 1,
    executionTimeMillis: 7,
    totalKeysExamined: 1,
    totalDocsExamined: 1,
    executionStages: {
      stage: 'FETCH',
      nReturned: 1,
      executionTimeMillisEstimate: 0,
      works: 2,
      advanced: 1,
      needTime: 0,
      needYield: 0,
      saveState: 0,
      restoreState: 0,
      isEOF: 1,
      docsExamined: 1,
      alreadyHasObj: 0,
      inputStage: {
        stage: 'IXSCAN',
        nReturned: 1,
        executionTimeMillisEstimate: 0,
        works: 2,
        advanced: 1,
        needTime: 0,
        needYield: 0,
        saveState: 0,
        restoreState: 0,
        isEOF: 1,
        keyPattern: { item: 1 },
        indexName: 'item_1',
        isMultiKey: false,
        multiKeyPaths: { item: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: { item: [ '["paper", "paper"]' ] },
myDb>
        seeks: 1,
        dupsTested: 0,
        dupsDropped: 0
      }
    }
  },
  command: { find: 'inventory', filter: { item: 'paper' }, '$db': 'myDb' },
  serverInfo: {
    host: 'DESKTOP-KAUFCR7',
    port: 27017,
    version: '7.0.12',
    gitVersion: 'b6513ce0781db6818e24619e8a461eae90bc94fc'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600,
    internalQueryFrameworkControl: 'trySbeRestricted'
  },
  ok: 1
}


Compound Index:
...............

db.<collection>.createIndex( {
   <field1>: <sortOrder>,
   <field2>: <sortOrder>,
   ...
   <fieldN>: <sortOrder>
} )

Get All Indexs:
..............
myDb> db.inventory.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { item: 1 }, name: 'item_1' }
]

here _id is implicitly indexed, if you want to search based _id , there is no need of explicit index.

Drop the Index:
..............
db.inventory.dropIndex('item_1')
{ nIndexesWas: 2, ok: 1 }

.....................................................................................
			   Update Document
		
in order to update , we have following methods

Collection.updateOne()
Collection.updateMany()
Collection.replaceOne()	

Mock Data
db.inventory.insertMany( [
   { item: "canvas", qty: 100, size: { h: 28, w: 35.5, uom: "cm" }, status: "A" },
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "mat", qty: 85, size: { h: 27.9, w: 35.5, uom: "cm" }, status: "A" },
   { item: "mousepad", qty: 25, size: { h: 19, w: 22.85, uom: "cm" }, status: "P" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "P" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" },
   { item: "sketchbook", qty: 80, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "sketch pad", qty: 95, size: { h: 22.85, w: 30.5, uom: "cm" }, status: "A" }
] );


Update Documents in a Collection
  To update a document, MongoDB provides update operators, such as $set, to modify field values.

  To use the update operators, pass to the update methods an update document of the form:

{
  <update operator>: { <field1>: <value1>, ... },
  <update operator>: { <field2>: <value2>, ... },
  ...
}

Some update operators, such as $set, will create the field if the field does not exist.

Update a Single Document :
...........................

Syntax:
db.collection.updateOne(filter, update, options)


filter:

 The selection criteria for the update. The same query selectors as in the find()  method are available.

Specify an empty document { } to update the first document returned in the collection.


update:
  The modifications to apply. Can be one of the following:
  Update document  -  Contains only update operator expressions.
{
  <update operator>: { <field1>: <value1>, ... },
  <update operator>: { <field2>: <value2>, ... },
  ...
}

Aggregation pipeline - Contains only the following aggregation stages:

 $addFields and its alias $set
 $project and its alias $unset
 $replaceRoot and its alias $replaceWith

options:
  There are lot of options , we will see only few options

upsert  boolean
{upsert:true or false}

Optional. When true, updateOne() either:

1.Creates a new document if no documents match the filter. 
2.Updates a single document that matches the filter.
3.To avoid multiple upserts, ensure that the filter field(s) are uniquely indexed.
 Defaults to false, which does not insert a new document when no match is found.

myDb> db.inventory.updateOne(
...    { item: "paper" },
...    {
...      $set: { "size.uom": "cm", status: "P" },
...      $currentDate: { lastModified: true }
...    }
... )
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}

The update operation:

1.uses the $set operator to update the value of the size.uom field to "cm" and the value of the status field to "P",
2.uses the $currentDate operator to update the value of the lastModified field to the current date. If lastModified field does not exist, $currentDate will create the field. 

Update Multiple Documents:
.........................
 The following example uses the db.collection.updateMany() method on the inventory collection to update all documents where qty is less than 50:

myDb> db.inventory.updateMany(
...    { "qty": { $lt: 50 } },
...    {
...      $set: { "size.uom": "in", status: "P" },
...      $currentDate: { lastModified: true }
...    }
... );

Replace a Document:
...................

   To replace the entire content of a document except for the _id field, pass an entirely new document as the second argument to db.collection.replaceOne().

When replacing a document, the replacement document must consist of only field/value pairs. The replacement document cannot include update operators expressions.

The replacement document can have different fields from the original document. In the replacement document, you can omit the _id field since the _id field is immutable. However, if you do include the _id field, it must have the same value as the current value.


myDb> db.inventory.find({item:'paper'})
[
  {
    _id: ObjectId('66cf0ed3ffea971f1d2710ce'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'cm' },
    status: 'P',
    lastModified: ISODate('2024-08-28T12:03:07.667Z')
  }
]
myDb>

myDb> db.inventory.replaceOne(
...    { item: "paper" },
...    { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 40 } ] }
... );
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
myDb> db.inventory.find({item:'paper'})
[
  {
    _id: ObjectId('66cf0ed3ffea971f1d2710ce'),
    item: 'paper',
    instock: [ { warehouse: 'A', qty: 60 }, { warehouse: 'B', qty: 40 } ]
myDb>
]
....................................................................................
			  Remove -Delete Documents
...................................................................................
db.collection.deleteOne(filter)
 Delete at most a single document that match a specified filter even though multiple documents may match the specified filter.
db.collection.deleteMany(filter)
  Delete all documents that match a specified filter.
db.collection.remove(filter)
   Delete a single document or all documents that match a specified filter.

Mock Data:
db.inventory.insertMany( [
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "P" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" },
] );

Delete Only One Document that Matches a Condition:

To delete at most a single document that matches a specified filter (even though multiple documents may match the specified filter) use the db.collection.deleteOne() method.

The following example deletes the first document where status is "D":

db.inventory.deleteOne( { status: "D" } )

Delete Many:

Delete All Documents that Match a Condition
You can specify criteria, or filters, that identify the documents to delete. The filters use the same syntax as read operations.

To specify equality conditions, use <field>:<value> expressions in the query filter document:

{ <field1>: <value1>, ... }


A query filter document can use the query operators to specify conditions in the following form:

{ <field1>: { <operator1>: <value1> }, ... }


To delete all documents that match a deletion criteria, pass a filter parameter to the deleteMany() method.

The following example removes all documents from the inventory collection where the status field equals "A":

myDb> db.inventory.deleteMany({ status : "A" })
{ acknowledged: true, deletedCount: 6 }
....................................................................................
			Aggregation Pipeline
....................................................................................

Aggregation in MongoDB is a way to process data records and return computed results. 

It allows users to transform data more powerfully than the find() command by using multiple stages and expressions to build a pipeline of operations on their data. The aggregation pipeline runs in the MongoDB server and can be optimized before running


MongoDB Aggregation is a powerful database process that allows you to perform complex data transformations and computations on collections of documents or rows. Here are the key points:

Aggregation Pipelines:
......................

1.Aggregation pipelines are the preferred method for performing aggregations in MongoDB.
2.A pipeline consists of one or more stages that process documents sequentially.
3.Each stage performs an operation on the input documents (e.g., filtering, grouping, calculating values).
4.The output from one stage becomes the input for the next stage.
5.You can use aggregation pipelines to:
    5.1.Group values from multiple documents together.
    5.2.Perform operations on grouped data to return a single result.  
    5.3.Analyze data changes over time.


To perform aggregation operations, you can use:

Aggregation pipelines, which are the preferred method for performing aggregations.

Single purpose aggregation methods, which are simple but lack the capabilities of an aggregation pipeline.

Pipline Operators:

$match
$project
$sort
$sum
$group
$avg
$set
$unset
etc...

Basic Aggregation Operators:
............................
Mock data:
db.orders.insertMany( [
   { _id: 0, name: "Pepperoni", size: "small", price: 19,
     quantity: 10, date: ISODate( "2021-03-13T08:14:30Z" ) },
   { _id: 1, name: "Pepperoni", size: "medium", price: 20,
     quantity: 20, date : ISODate( "2021-03-13T09:13:24Z" ) },
   { _id: 2, name: "Pepperoni", size: "large", price: 21,
     quantity: 30, date : ISODate( "2021-03-17T09:22:12Z" ) },
   { _id: 3, name: "Cheese", size: "small", price: 12,
     quantity: 15, date : ISODate( "2021-03-13T11:21:39.736Z" ) },
   { _id: 4, name: "Cheese", size: "medium", price: 13,
     quantity:50, date : ISODate( "2022-01-12T21:23:13.331Z" ) },
   { _id: 5, name: "Cheese", size: "large", price: 14,
     quantity: 10, date : ISODate( "2022-01-12T05:08:13Z" ) },
   { _id: 6, name: "Vegan", size: "small", price: 17,
     quantity: 10, date : ISODate( "2021-01-13T05:08:13Z" ) },
   { _id: 7, name: "Vegan", size: "medium", price: 18,
     quantity: 10, date : ISODate( "2021-01-13T05:10:13Z" ) }
] )


Use Case:
 Return single Field:

myDb> db.orders.aggregate([{$project:{_id:1}}])
[
  { _id: 0 },
  { _id: 1 },
  { _id: 2 },
  { _id: 3 },
  { _id: 4 },
  { _id: 5 },
  { _id: 6 },
  { _id: 7 }
]

Use Case:
  Sort records based data + Projections
myDb> db.orders.aggregate([
... {$project:{name:{$toUpper:"$name"},_id:0}},
... {$sort:{date:1}}])
[
  { name: 'PEPPERONI' },
  { name: 'PEPPERONI' },
  { name: 'PEPPERONI' },
  { name: 'CHEESE' },
  { name: 'CHEESE' },
  { name: 'CHEESE' },
  { name: 'VEGAN' },
  { name: 'VEGAN' }
]


myDb> db.orders.aggregate( [
...
...    // Stage 1: Filter pizza order documents by pizza size
...    {
...       $match: { size: "medium" }
...    },
...
...    // Stage 2: Group remaining documents by pizza name and calculate total quantity
...    {
...       $group: { _id: "$name", totalQuantity: { $sum: "$quantity" } }
...    }
...
... ] );
[
  { _id: 'Vegan', totalQuantity: 10 },
  { _id: 'Pepperoni', totalQuantity: 20 },
  { _id: 'Cheese', totalQuantity: 50 }
]
.....................................................................................
			Complex Pipelines
.....................................................................................
When To Use $set & $unset
 
   You should use $set & $unset stages when you need to "retain most of the fields" in the input records, and you want to add, modify or remove a minority subset of fields. This is the case for most uses of aggregation pipelines.

For example, imagine there is a collection of credit card payment documents similar to the following:

{
  _id: ObjectId("6044faa70b2c21f8705d8954"),
  card_name: "Mrs. Jane A. Doe",
  card_num: "1234567890123456",
  card_expiry: "2023-08-31T23:59:59.736Z",
  card_sec_code: "123",
  card_provider_name: "Credit MasterCard Gold",
  transaction_id: "eb1bd77836e8713656d9bf2debba8900",
  transaction_date: ISODate("2021-01-13T09:32:07.000Z"),
  transaction_curncy_code: "GBP",
  transaction_amount: NumberDecimal("501.98"),
  reported: true
}
....

[
  {"$set": {
    // Modified + new field
    "card_expiry": {"$dateFromString": {"dateString": "$card_expiry"}},
    "card_type": "CREDIT",        
  }},
  
  {"$unset": [
    // Remove _id field
    "_id",
  ]},
]
..........................

When To Use $project:

  It is best to use a $project stage when the required shape of output documents is very different from the input documents' shape. This situation often arises when you do not need to include most of the original fields.

   This time for the same input payments collection, let us imagine you require a new aggregation pipeline to produce result documents. You need each output document's structure to be very different from the input structure, and you need to retain far fewer original fields, similar to the following:


[
  {"$project": {
    // Add some fields
    "transaction_info.date": "$transaction_date",
    "transaction_info.amount": "$transaction_amount",
    "status": {"$cond": {"if": "$reported", "then": "REPORTED", "else": 	      "UNREPORTED"}},
    
    // Remove _id field
    "_id": 0,
  }},
]
.....................................................................................

Aggregation Expressions:
.....................................

Expressions give aggregation pipelines their data manipulation power.

However, they tend to be something. Proficiency in aggregation pipelines demands a deeper understanding of expressions.

Aggregation expressions come in one of three primary flavours:

Operators. 
.........
Accessed as an object with a $ prefix followed by the operator function name. The "dollar-operator-name" is used as the main key for the object.  Examples: {$arrayElemAt: ...}, {$cond: ...}, {$dateToString: ...}

Field Paths.
...........
 Accessed as a string with a $ prefix followed by the field's path in each record being processed.  Examples: "$account.sortcode", "$addresses.address.city"

Variables.
..........
 Accessed as a string with a $$ prefix followed by the fixed name and falling into three sub-categories:

1.Context System Variables.
    With values coming from the system environment rather than each input record an aggregation stage is processing.  Examples: "$$NOW", "$$CLUSTER_TIME"

2.Marker Flag System Variables.
   To indicate desired behaviour to pass back to the aggregation runtime.  Examples: "$$ROOT", "$$REMOVE", "$$PRUNE"

3.Bind User Variables.
 For storing values you declare with a $let operator (or with the let option of a $lookup stage, or as option of a $map or $filter stage).  Examples: "$$product_name_var", "$$orderIdVal"

  "customer_info": {"$cond": {
                    "if":   {"$eq": ["$customer_info.category", "SENSITIVE"]}, 
                    "then": "$$REMOVE", 
                    "else": "$customer_info",
                 }}

What do expressions Return?/Produce?

In all these cases, an expression is just something that dynamically populates and returns a new JSON/BSON data type element, which can be one of:

a Number  (including integer, long, float, double, decimal128)
a String  (UTF-8)
a Boolean
a DateTime  (UTC)
an Array
an Object
...................................................................................
		   Expressions For Array Processing
....................................................................................
"If-Else" Conditional Comparison:
.................................

let order = {"product" : "WizzyWidget", "price": 25.99, "qty": 8};

// Procedural style JavaScript
if (order.qty > 5) {
  order.cost = order.price * order.qty * 0.9;
} else {
  order.cost = order.price * order.qty;
}
In a procedural style of JavaScript, you might write the following code to calculate the total order cost:

output:
{product: 'WizzyWidget', qty: 8, price: 25.99, cost: 187.128}

....

let order = {"product" : "WizzyWidget", "price": 25.99, "qty": 8};

db.customer_orders.insertOne(order);

Add new field - $set
Condition: $cond,$gte,$multiply

var pipeline = [
  {"$set": {
    "cost": {
      "$cond": { 
        "if":   {"$gte": ["$qty", 5]}, 
        "then": {"$multiply": ["$price", "$qty", 0.9]},
        "else": {"$multiply": ["$price", "$qty"]},
      }    
    },
  }},
];

db.customer_orders.aggregate(pipeline);

..................................................................................

Array Transformation:
......................
"For-Each" Looping To Transform An Array


Use case:
  Imagine you wanted to process a list of the products ordered by a customer and convert the array of product names to uppercase.

let order = {
  "orderId": "AB12345",
  "products": ["Laptop", "Kettle", "Phone", "Microwave"]
};
 
// Procedural style JavaScript
for (let pos in order.products) {
  order.products[pos] = order.products[pos].toUpperCase();
}

{
  "orderId": "AB12345",
  "products": ["Laptop", "Kettle", "Phone", "Microwave"]
};

db.orders.insertOne(order);

var pipeline = [
  {"$set": {
    "products": {
      "$map": {
        "input": "$products",
        "as": "product", //declare variable
        "in": {"$toUpper": "$$product"}
      }
    }
  }}
];

db.orders.aggregate(pipeline);
.....................................................................................
Complex Examples:

Scenario:
You want to query a collection of people to find the three youngest people who have a job in engineering, sorted by the youngest person first.


Mock data:

// Create an index for a persons collection
db.persons.createIndex({"vocation": 1, "dateofbirth": 1});

// Insert records into the persons collection
db.persons.insertMany([
  {
    "person_id": "6392529400",
    "firstname": "Elise",
    "lastname": "Smith",
    "dateofbirth": ISODate("1972-01-13T09:32:07Z"),
    "vocation": "ENGINEER",
    "address": { 
        "number": 5625,
        "street": "Tipa Circle",
        "city": "Wojzinmoj",
    },
  },
  {
    "person_id": "1723338115",
    "firstname": "Olive",
    "lastname": "Ranieri",
    "dateofbirth": ISODate("1985-05-12T23:14:30Z"),    
    "gender": "FEMALE",
    "vocation": "ENGINEER",
    "address": {
        "number": 9303,
        "street": "Mele Circle",
        "city": "Tobihbo",
    },
  },
  {
    "person_id": "8732762874",
    "firstname": "Toni",
    "lastname": "Jones",
    "dateofbirth": ISODate("1991-11-23T16:53:56Z"),    
    "vocation": "POLITICIAN",
    "address": {
        "number": 1,
        "street": "High Street",
        "city": "Upper Abbeywoodington",
    },
  },
  {
    "person_id": "7363629563",
    "firstname": "Bert",
    "lastname": "Gooding",
    "dateofbirth": ISODate("1941-04-07T22:11:52Z"),    
    "vocation": "FLORIST",
    "address": {
        "number": 13,
        "street": "Upper Bold Road",
        "city": "Redringtonville",
    },
  },
  {
    "person_id": "1029648329",
    "firstname": "Sophie",
    "lastname": "Celements",
    "dateofbirth": ISODate("1959-07-06T17:35:45Z"),    
    "vocation": "ENGINEER",
    "address": {
        "number": 5,
        "street": "Innings Close",
        "city": "Basilbridge",
    },
  },
  {
    "person_id": "7363626383",
    "firstname": "Carl",
    "lastname": "Simmons",
    "dateofbirth": ISODate("1998-12-26T13:13:55Z"),    
    "vocation": "ENGINEER",
    "address": {
        "number": 187,
        "street": "Hillside Road",
        "city": "Kenningford",
    },
  },
]);
.....................................................................................

How to write Pipline?

$match:
https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/

var pipeline= [ 
 //stage-1: Match Engineers only
  {"$match": {
    "vocation": "ENGINEER",
  }},
  //stage-2:Sort by youngest Person first
  {
    "$sort":{
      "dateofbirth":-1
     }
  },

  //State-3:only include the first 3 youngest people
  {
    "$limit":3
  },
  //Stage-4: Exclude unrequired fields from each person record
  {
    "$unset": [
       "_id",
       "vocation",
       "address"
     ]
  }

]

myDb> db.persons.aggregate(pipeline);
[
  {
    person_id: '7363626383',
    firstname: 'Carl',
    lastname: 'Simmons',
    dateofbirth: ISODate('1998-12-26T13:13:55.000Z')
  },
  {
    person_id: '1723338115',
    firstname: 'Olive',
    lastname: 'Ranieri',
    dateofbirth: ISODate('1985-05-12T23:14:30.000Z'),
    gender: 'FEMALE'
  },
  {
    person_id: '6392529400',
    firstname: 'Elise',
    lastname: 'Smith',
    dateofbirth: ISODate('1972-01-13T09:32:07.000Z')
  }
]
....................................................................................

Scenario
You want to generate a report to show what each shop customer purchased in 2020. You will group the individual order records by customer, capturing each customer's first purchase date, the number of orders they made, the total value of all their orders and a list of their order items sorted by date.

// Create index for an orders collection
db.orders.createIndex({"orderdate": -1});

// Insert records into the orders collection
db.orders.insertMany([
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-05-30T08:35:52Z"),
    "value": NumberDecimal("231.43"),
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-01-13T09:32:07Z"),
    "value": NumberDecimal("99.99"),
  },
  {
    "customer_id": "oranieri@warmmail.com",
    "orderdate": ISODate("2020-01-01T08:25:37Z"),
    "value": NumberDecimal("63.13"),
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2019-05-28T19:13:32Z"),
    "value": NumberDecimal("2.01"),
  },  
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2020-11-23T22:56:53Z"),
    "value": NumberDecimal("187.99"),
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2020-08-18T23:04:48Z"),
    "value": NumberDecimal("4.59"),
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-12-26T08:55:46Z"),
    "value": NumberDecimal("48.50"),
  },
  {
    "customer_id": "tj@wheresmyemail.com",
    "orderdate": ISODate("2021-02-29T07:49:32Z"),
    "value": NumberDecimal("1024.89"),
  },
  {
    "customer_id": "elise_smith@myemail.com",
    "orderdate": ISODate("2020-10-03T13:49:44Z"),
    "value": NumberDecimal("102.24"),
  },
]);

Tips:
$match
$sort
$group
$set

Excepted Result:
[
  {
    customer_id: 'oranieri@warmmail.com',
    first_purchase_date: ISODate('2020-01-01T08:25:37.000Z'),
    total_value: NumberDecimal('63.13'),
    total_orders: 1,
    orders: [
      {orderdate: ISODate('2020-01-01T08:25:37.000Z'), value: NumberDecimal('63.13')}
    ]
  },
  {
    customer_id: 'elise_smith@myemail.com',
    first_purchase_date: ISODate('2020-01-13T09:32:07.000Z'),
    total_value: NumberDecimal('482.16'),
    total_orders: 4,
    orders: [
      {orderdate: ISODate('2020-01-13T09:32:07.000Z'), value: NumberDecimal('99.99')},
      {orderdate: ISODate('2020-05-30T08:35:52.000Z'), value: NumberDecimal('231.43')},
      {orderdate: ISODate('2020-10-03T13:49:44.000Z'), value: NumberDecimal('102.24')},
      {orderdate: ISODate('2020-12-26T08:55:46.000Z'), value: NumberDecimal('48.50')}
    ]
  },
  {
    customer_id: 'tj@wheresmyemail.com',
    first_purchase_date: ISODate('2020-08-18T23:04:48.000Z'),
    total_value: NumberDecimal('192.58'),
    total_orders: 2,
    orders: [
      {orderdate: ISODate('2020-08-18T23:04:48.000Z'), value: NumberDecimal('4.59')},
      {orderdate: ISODate('2020-11-23T22:56:53.000Z'), value: NumberDecimal('187.99')}
    ]
  }
]
.....................................................................................
			Bulk Operations
....................................................................................

MongoDB provides clients the ability to perform write operations in bulk. Bulk write operations affect a single collection. MongoDB allows applications to determine the acceptable level of acknowledgment required for bulk write operations.

The db.collection.bulkWrite() method provides the ability to perform bulk insert, update, and delete operations.

MongoDB also supports bulk insert through the db.collection.insertMany() method.

bulkWrite() Methods

bulkWrite() supports the following write operations:

insertOne
updateOne
updateMany
replaceOne
deleteOne
deleteMany

Mock data:
db.pizzas.insertMany( [
   { _id: 0, type: "pepperoni", size: "small", price: 4 },
   { _id: 1, type: "cheese", size: "medium", price: 7 },
   { _id: 2, type: "vegan", size: "large", price: 8 }
] )

The following bulkWrite() example runs these operations on the pizzas collection:

Adds two documents using insertOne.

Updates a document using updateOne.

Deletes a document using deleteOne.

Replaces a document using replaceOne.

try {
   db.pizzas.bulkWrite( [
      { insertOne: { document: { _id: 3, type: "beef", size: "medium", price: 6 } } },
      { insertOne: { document: { _id: 4, type: "sausage", size: "large", price: 10 } } },
      { updateOne: {
         filter: { type: "cheese" },
         update: { $set: { price: 8 } }
      } },
      { deleteOne: { filter: { type: "pepperoni"} } },
      { replaceOne: {
         filter: { type: "vegan" },
         replacement: { type: "tofu", size: "small", price: 4 }
      } }
   ] )
} catch( error ) {
   print( error )
}
.....................................................................................
			   Data Modeling
.....................................................................................

	 "Data that is accssed togther should be stored together"

Schema Design Process:
......................

The schema design process helps you prepare an effective schema for your application.

 Following the schema design process helps you identify what data your application needs and how to best organize your data to optimize performance.
			
Use Cases:
...........
  Planning and designing your schema is best done early in your application development process.

 Starting your application with good data modeling practices helps prevent schema and performance issues as your application grows.

 When you follow schema design practices early and appropriately, you can achieve better performance and make it easier to scale your application in the future.

  You can design your schema iteratively and modify your schema as the needs of your application change.

 MongoDB provides ways to seamlessly modify your schema without downtime. However, it can still be difficult to modify large-scale schemas that are used in production.

  When you design your schema, you may need to strike a balance between performance and simplicity. 

   Sometimes, the most performant schema takes many iterations and a great deal of testing to achieve.

   Depending on your application and the importance of optimization, you may want to establish a simple schema to cover basic functionality, before spending time on optimizations.


Plan Your schema:
   There are three process are applied to design design schema.


1.Identify the data your application work load

 To identify the data that your application needs, consider the following factors:
   
   1.1.Your application's users and the information they need.
   1.2.Your business domain.
   1.3.Application logs and frequently-run queries.

see presentation:

Map Schema Relationships: / Map relationships between objects in Your collections

 When you design your schema, consider how your application needs to query and return related data. 
   How you map relationships between data entities affects your application's performance and scalability.

   "The recommended way to handle related data is to embed it in a sub-document"
 
   "Embedding related data lets your application query the data it needs with a single read operation and avoid slow $lookup operations"

Steps:
1.Identify related data in your schema
2.Create a schema map for your related data
3.Choose whether to embed related data or use references

Relationship Types:

1.Embeding References
2.References

1.Embeding References

1.One to one
2.One to Many
3.Many to Many

1.References

1.One to one
2.One to Many
3.Many to Many


