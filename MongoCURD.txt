CURD :


Creating a Collection
If the collection does not currently exist, insert operations will create the collection.

Insert a Single Document
...............................

db.collection.insertOne() inserts a single document into a collection.

The following example inserts a new document into the inventory collection. If the document does not specify an _id field, MongoDB adds the _id field with an ObjectId value to the new document.

 db.message.insertOne({_id:1,message:'Hello'})
{ acknowledged: true, insertedId: 1 }

test> db.message.find()
[ { _id: 1, message: 'Hello' } ]
test> db.message.insertOne({message:'Hello'})
{
  acknowledged: true,
  insertedId: ObjectId('66cc8d804508433b442710bc')
}
test> db.message.find()
[
  { _id: 1, message: 'Hello' },
  { _id: ObjectId('66cc8d804508433b442710bc'), message: 'Hello' }


Bson Type System:

It supports all json type + extra types

Each BSON type has both integer and string identifiers as listed in the following table:



Type  Number  Alias 

Double 1     "double"
String 2     "string"
Object 3     "object"
Array  4     "array"
Binary data 5 "binData"
Undefined 6  "undefined"
ObjectId 7   "objectId"
Boolean 8    "bool"
Date  9       "date"
Null  10     "null"
Regular Expression 11 "regex"
DBPointer  12  "dbPointer"
JavaScript 13 "javascript"
Symbol 14 "symbol"
32-bit integer 16 "int"
Timestamp 17 "timestamp" 
64-bit integer 18 "long"
Decimal128 19 "decimal"
Min key -1 "minKey"
Max key 127 "maxKey

How to insert with explicit type:

{ _id: 1, value: 1, expectedType: 'Int32' },
{ _id: 2, value: Long("1"), expectedType: 'Long' },
{ _id: 3, value: 1.01, expectedType: 'Double' },
{ _id: 4, value: Decimal128("1.01"), expectedType: 'Decimal128' },
{ _id: 5, value: 3200000001, expectedType: 'Double' }

What is ObjectId in MongoDB
In MongoDB, every document within a collection contains an “_id” field that uniquely identifies it, serving as the primary key. The default format for this field is the ObjectId, a 12-byte BSON type that ensures uniqueness and embeds useful metadata, such as the creation timestamp.

MongoDB ObjectId
Every document in the collection has an “_id” field that is used to uniquely identify the document in a particular collection it acts as the primary key for the documents in the collection. The “_id” field can be used in any format and the default format is the ObjectId of the document.

An ObjectID is a 12-byte Field Of BSON type

The first 4 bytes represent the Unix Timestamp of the document.
The next 3 bytes are the machine ID on which the MongoDB server is running.
The next 2 bytes are of the process ID.
The last Field is 3 bytes used for incrementing the objectid.

Format of ObjectId:
ObjectId(<hexadecimal>)
ObjectId accepts one parameter which is optional Hexadecimal ObjectId in String.

We can give our own ObjectId to the document but it must be unique.

Key Characteristics of MongoDB ObjectId:
Uniqueness: Ensures each document has a unique identifier within a collection.
Timestamp: Embeds a timestamp, allowing you to extract the creation time of the document.
Efficiency: Provides a compact, efficient way to generate unique identifiers without requiring coordination across servers.


mydb> db.test.insertOne({_id:1,value:'Hello'})
{ acknowledged: true, insertedId: 1 }
mydb> db.test.insertOne({_id:1,value:'Hai'})
MongoServerError: E11000 duplicate key error collection: mydb.test index: _id_ dup key: { _id: 1 }

Date
mongosh provides various methods to return the date, either as a string or as a Date object:

Date() method which returns the current date as a string.

new Date() constructor which returns a Date object using the ISODate() wrapper.

ISODate() constructor which returns a Date object using the ISODate() wrapper.



Eg with expclit data type:

mydb> db.col.insertOne({_id:new ObjectId(),name:'Subramanian',dob:new Date(),age:new Int32()})
{
  acknowledged: true,
  insertedId: ObjectId('66ccaa9d4508433b442710c0')
}

.......

Insert Multiple Documents:
db.collection.insertMany() can insert multiple documents into a collection. Pass an array of documents to the method.

mydb> db.names.insertMany([{name:'subramanian'},{name:'murugan'},{name:'Karthik'}])
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId('66ccae264508433b442710c5'),
    '1': ObjectId('66ccae264508433b442710c6'),
    '2': ObjectId('66ccae264508433b442710c7')
  }
}

insertMany() returns a document that includes the newly inserted documents _id field values.

Insert Behavior
Collection Creation
If the collection does not currently exist, insert operations will create the collection.
....................................................................................
			How to insert Embedded/Nested Documents
....................................................................................
mydb> db.customer.insertOne({name:'John',address: { city:'Coimbatore'}})
{
  acknowledged: true,
  insertedId: ObjectId('66ccb2244508433b442710c8')
}
mydb> db.customer.find()
[
  {
    _id: ObjectId('66ccb2244508433b442710c8'),
    name: 'John',
    address: { city: 'Coimbatore' }
  }
]
.....................................................................................
			How to insert Arrays/List -Embedded/Nested Documents
.....................................................................................

Simple List:
mydb> db.employees.insertOne({name:'Subramaian',skills:['java','javascript']})
{
  acknowledged: true,
  insertedId: ObjectId('66ccb27c4508433b442710c9')
}
mydb> db.employees.find()
[
  {
    _id: ObjectId('66ccb27c4508433b442710c9'),
    name: 'Subramaian',
    skills: [ 'java', 'javascript' ]
  }
]
Complex List:
mydb> db.products.insertOne({name:'Iphone',lineItems:[{id:1,item:'phone'},{id:2,item:'SmartPhone'}]})
{
  acknowledged: true,
  insertedId: ObjectId('66ccb2d74508433b442710ca')
}
mydb> db.products.find()
[
  {
    _id: ObjectId('66ccb2d74508433b442710ca'),
    name: 'Iphone',
    lineItems: [ { id: 1, item: 'phone' }, { id: 2, item: 'SmartPhone' } ]
  }
]
.....................................................................................
			Query 
.....................................................................................

1. Find All Documents
   To retrieve all documents in a collection:
				
db.inventory.insertMany([
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);


To select all documents in the collection, pass an empty document as the query filter parameter to the find method. The query filter parameter determines the select criteria:

db.inventory.find( {} )

db.collection.find(query, projection, options)

parameter   type        Description
query       document    Optional. Specifies selection filter using query operators. 	            		To return all documents in a collection, omit this parameter 			        or pass an empty document ({}).

projection document    Optional. Specifies the fields to return in the documents that 		       match the query filter. To return all fields in the matching 		               documents, omit this parameter

options   document    Optional. Specifies additional options for the query. These 		              options modify query behavior and how results are returned.

This operation uses a filter predicate of {}, which corresponds to the following SQL statement:

SELECT * FROM inventory


eg:
mydb> db.inventory.find()
[
  {
    _id: ObjectId('66cd308b3d125dbf642710bc'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710bd'),
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710be'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710bf'),
    item: 'planner',
    qty: 75,
    size: { h: 22.85, w: 30, uom: 'cm' },
    status: 'D'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710c0'),
    item: 'postcard',
    qty: 45,
    size: { h: 10, w: 15.25, uom: 'cm' },
    status: 'A'
  }
]
mydb> db.inventory.find({})
[
  {
    _id: ObjectId('66cd308b3d125dbf642710bc'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710bd'),
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710be'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710bf'),
    item: 'planner',
    qty: 75,
    size: { h: 22.85, w: 30, uom: 'cm' },
    status: 'D'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710c0'),
    item: 'postcard',
    qty: 45,
    size: { h: 10, w: 15.25, uom: 'cm' },
    status: 'A'
  }
]
.....................................................................................
			Specify Equality Condition

To specify equality conditions, use <field>:<value> expressions in the query filter document:


{ <field1>: <value1>, ... }


eg:
mydb> db.inventory.find( { status: "D" } )
[
  {
    _id: ObjectId('66cd308b3d125dbf642710be'),
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710bf'),
    item: 'planner',
    qty: 75,
    size: { h: 22.85, w: 30, uom: 'cm' },
    status: 'D'
  }
]

This operation uses a filter predicate of { status: "D" }, which corresponds to the following SQL statement:

SELECT * FROM inventory WHERE status = "D"
.....................................................................................
			Specify Conditions Using Query Operators


Query Selectors:
Comparison

$eq
Matches values that are equal to a specified value.

$gt
Matches values that are greater than a specified value.

$gte
Matches values that are greater than or equal to a specified value.

$in
Matches any of the values specified in an array.

$lt
Matches values that are less than a specified value.

$lte
Matches values that are less than or equal to a specified value.

$ne
Matches all values that are not equal to a specified value.

$nin
Matches none of the values specified in an array.

Logical

$and
Joins query clauses with a logical AND returns all documents that match the conditions of both clauses.

$not
Inverts the effect of a query expression and returns documents that do not match the query expression.

$nor
Joins query clauses with a logical NOR returns all documents that fail to match both clauses.

$or
Joins query clauses with a logical OR returns all documents that match the conditions of either clause.

Element:
$exists
Matches documents that have the specified field.
$type
Selects documents if a field is of the specified type.

Array
$all
Matches arrays that contain all elements specified in the query.

$elemMatch
Selects documents if element in the array field matches all the specified $elemMatch conditions.

$size
Selects documents if the array field is a specified size.

Projection Operators

Name
Description
$
Projects the first element in an array that matches the query condition.
$elemMatch
Projects the first element in an array that matches the specified $elemMatch condition.
$meta
Projects the document's score assigned during the $text operation.

Miscellaneous Operators

$comment
Adds a comment to a query predicate.
$rand
Generates a random float between 0 and 1.

Selection Using Operators:
..........................

{ <field1>: { <operator1>: <value1> }, ... }

The following example retrieves all documents from the inventory collection where status equals either "A" or "D":

db.inventory.find( { status: { $in: [ "A", "D" ] } } )

The operation uses a filter predicate of { status: { $in: [ "A", "D" ] } }, which corresponds to the following SQL statement:

SELECT * FROM inventory WHERE status in ("A", "D")


Specify AND Conditions
A compound query can specify conditions for more than one field in the collection's documents. Implicitly, a logical AND conjunction connects the clauses of a compound query so that the query selects the documents in the collection that match all the conditions.

The following example retrieves all documents in the inventory collection where the status equals "A" and qty is less than ($lt) 30:

mydb> db.inventory.find( { status: "A", qty: { $lt: 30 } } )
[
  {
    _id: ObjectId('66cd308b3d125dbf642710bc'),
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  }
]

The operation uses a filter predicate of { status: "A", qty: { $lt: 30 } }, which corresponds to the following SQL statement:

SELECT * FROM inventory WHERE status = "A" AND qty < 30

................................................................................

Specify OR Conditions
Using the $or operator, you can specify a compound query that joins each clause with a logical OR conjunction so that the query selects the documents in the collection that match at least one condition.

The following example retrieves all documents in the collection where the status equals "A" or qty is less than ($lt) 30:


The operation uses a filter predicate of { $or: [ { status: 'A' }, { qty: { $lt: 30 } } ] }, which corresponds to the following SQL statement:

SELECT * FROM inventory WHERE status = "A" OR qty < 30
...................................................................................

Specify AND as well as OR Conditions


In the following example, the compound query document selects all documents in the collection where the status equals "A" and either qty is less than ($lt) 30 or item starts with the character p:

	
db.inventory.find( {
     status: "A",
     $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ]
} )

or
{
   status: 'A',
   $or: [
     { qty: { $lt: 30 } }, { item: { $regex: '^p' } }
   ]
}
.....................................................................................
				Projection
.....................................................................................

To include or exclude specific fields in the result:

The projection parameter determines which fields are returned in the matching documents. The projection parameter takes a document of the following form:

{ <field1>: <value>, <field2>: <value> ... }

<field>: <1 or true>
Specifies the inclusion of a field. If you specify a non-zero integer for the projection value, the operation treats the value as true.

<field>: <0 or false>
Specifies the exclusion of a field

<field>: <aggregation expression>
Specifies the value of the projected field.

{ field: [ 1, 2, 3, "$someExistingField" ] }

{ field: "New String Value" }

{ field: { status: "Active", total: { $sum: "$existingArray" } } }
..

mydb> db.inventory.find({},{"_id":0})
[
  {
    item: 'journal',
    qty: 25,
    size: { h: 14, w: 21, uom: 'cm' },
    status: 'A'
  },
  {
    item: 'notebook',
    qty: 50,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'A'
  },
  {
    item: 'paper',
    qty: 100,
    size: { h: 8.5, w: 11, uom: 'in' },
    status: 'D'
  },
  {
    item: 'planner',
    qty: 75,
    size: { h: 22.85, w: 30, uom: 'cm' },
    status: 'D'
  },
  {
    item: 'postcard',
    qty: 45,
    size: { h: 10, w: 15.25, uom: 'cm' },
    status: 'A'
  }
]
...

Inclusion or Exclusion
A projection cannot contain both include and exclude specifications, with the exception of the _id field:

In projections that explicitly include fields, the _id field is the only field that you can explicitly exclude.

In projections that explicitly excludes fields, the _id field is the only field that you can explicitly include; however, the _id field is included by default.


Specify the Fields to Return
............................

https://www.mongodb.com/docs/manual/reference/method/db.collection.find/#std-label-find-projection-examples

  The following operation finds all documents in the bios collection and returns only the name field, contribs field and _id field:

db.bios.insertMany([
   {
       "_id" : 1,
       "name" : {
           "first" : "John",
           "last" : "Backus"
       },
       "birth" : ISODate("1924-12-03T05:00:00Z"),
       "death" : ISODate("2007-03-17T04:00:00Z"),
       "contribs" : [
           "Fortran",
           "ALGOL",
           "Backus-Naur Form",
           "FP"
       ],
       "awards" : [
           {
               "award" : "W.W. McDowell Award",
               "year" : 1967,
               "by" : "IEEE Computer Society"
           },
           {
               "award" : "National Medal of Science",
               "year" : 1975,
               "by" : "National Science Foundation"
           },
           {
               "award" : "Turing Award",
               "year" : 1977,
               "by" : "ACM"
           },
           {
               "award" : "Draper Prize",
               "year" : 1993,
               "by" : "National Academy of Engineering"
           }
       ]
   },
   {
       "_id" : ObjectId("51df07b094c6acd67e492f41"),
       "name" : {
           "first" : "John",
           "last" : "McCarthy"
       },
       "birth" : ISODate("1927-09-04T04:00:00Z"),
       "death" : ISODate("2011-12-24T05:00:00Z"),
       "contribs" : [
           "Lisp",
           "Artificial Intelligence",
           "ALGOL"
       ],
       "awards" : [
           {
               "award" : "Turing Award",
               "year" : 1971,
               "by" : "ACM"
           },
           {
               "award" : "Kyoto Prize",
               "year" : 1988,
               "by" : "Inamori Foundation"
           },
           {
               "award" : "National Medal of Science",
               "year" : 1990,
               "by" : "National Science Foundation"
           }
       ]
   },
   {
       "_id" : 3,
       "name" : {
           "first" : "Grace",
           "last" : "Hopper"
       },
       "title" : "Rear Admiral",
       "birth" : ISODate("1906-12-09T05:00:00Z"),
       "death" : ISODate("1992-01-01T05:00:00Z"),
       "contribs" : [
           "UNIVAC",
           "compiler",
           "FLOW-MATIC",
           "COBOL"
       ],
       "awards" : [
           {
               "award" : "Computer Sciences Man of the Year",
               "year" : 1969,
               "by" : "Data Processing Management Association"
           },
           {
               "award" : "Distinguished Fellow",
               "year" : 1973,
               "by" : " British Computer Society"
           },
           {
               "award" : "W. W. McDowell Award",
               "year" : 1976,
               "by" : "IEEE Computer Society"
           },
           {
               "award" : "National Medal of Technology",
               "year" : 1991,
               "by" : "United States"
           }
       ]
   },
   {
       "_id" : 4,
       "name" : {
           "first" : "Kristen",
           "last" : "Nygaard"
       },
       "birth" : ISODate("1926-08-27T04:00:00Z"),
       "death" : ISODate("2002-08-10T04:00:00Z"),
       "contribs" : [
           "OOP",
           "Simula"
       ],
       "awards" : [
           {
               "award" : "Rosing Prize",
               "year" : 1999,
               "by" : "Norwegian Data Association"
           },
           {
               "award" : "Turing Award",
               "year" : 2001,
               "by" : "ACM"
           },
           {
               "award" : "IEEE John von Neumann Medal",
               "year" : 2001,
               "by" : "IEEE"
           }
       ]
   },
   {
       "_id" : 5,
       "name" : {
           "first" : "Ole-Johan",
           "last" : "Dahl"
       },
       "birth" : ISODate("1931-10-12T04:00:00Z"),
       "death" : ISODate("2002-06-29T04:00:00Z"),
       "contribs" : [
           "OOP",
           "Simula"
       ],
       "awards" : [
           {
               "award" : "Rosing Prize",
               "year" : 1999,
               "by" : "Norwegian Data Association"
           },
           {
               "award" : "Turing Award",
               "year" : 2001,
               "by" : "ACM"
           },
           {
               "award" : "IEEE John von Neumann Medal",
               "year" : 2001,
               "by" : "IEEE"
           }
       ]
   },
   {
       "_id" : 6,
       "name" : {
           "first" : "Guido",
           "last" : "van Rossum"
       },
       "birth" : ISODate("1956-01-31T05:00:00Z"),
       "contribs" : [
           "Python"
       ],
       "awards" : [
           {
               "award" : "Award for the Advancement of Free Software",
               "year" : 2001,
               "by" : "Free Software Foundation"
           },
           {
               "award" : "NLUUG Award",
               "year" : 2003,
               "by" : "NLUUG"
           }
       ]
   },
   {
       "_id" : ObjectId("51e062189c6ae665454e301d"),
       "name" : {
           "first" : "Dennis",
           "last" : "Ritchie"
       },
       "birth" : ISODate("1941-09-09T04:00:00Z"),
       "death" : ISODate("2011-10-12T04:00:00Z"),
       "contribs" : [
           "UNIX",
           "C"
       ],
       "awards" : [
           {
               "award" : "Turing Award",
               "year" : 1983,
               "by" : "ACM"
           },
           {
               "award" : "National Medal of Technology",
               "year" : 1998,
               "by" : "United States"
           },
           {
               "award" : "Japan Prize",
               "year" : 2011,
               "by" : "The Japan Prize Foundation"
           }
       ]
   },
   {
       "_id" : 8,
       "name" : {
           "first" : "Yukihiro",
           "aka" : "Matz",
           "last" : "Matsumoto"
       },
       "birth" : ISODate("1965-04-14T04:00:00Z"),
       "contribs" : [
           "Ruby"
       ],
       "awards" : [
           {
               "award" : "Award for the Advancement of Free Software",
               "year" : "2011",
               "by" : "Free Software Foundation"
           }
       ]
   },
   {
       "_id" : 9,
       "name" : {
           "first" : "James",
           "last" : "Gosling"
       },
       "birth" : ISODate("1955-05-19T04:00:00Z"),
       "contribs" : [
           "Java"
       ],
       "awards" : [
           {
               "award" : "The Economist Innovation Award",
               "year" : 2002,
               "by" : "The Economist"
           },
           {
               "award" : "Officer of the Order of Canada",
               "year" : 2007,
               "by" : "Canada"
           }
       ]
   },
   {
       "_id" : 10,
       "name" : {
           "first" : "Martin",
           "last" : "Odersky"
       },
       "contribs" : [
           "Scala"
       ]
   }

] )

db.bios.find( { }, { name: 1, contribs: 1 } )


Explicitly Excluded Fields
...........................
The following operation queries the bios collection and returns all fields except the first field in the name embedded document and the birth field:

db.bios.find(
   { contribs: 'OOP' },
   { 'name.first': 0, birth: 0 }
)


Replace existing values:
mydb> db.inventory.find({},{status:'Hello',item:1})
[
  {
    _id: ObjectId('66cd308b3d125dbf642710bc'),
    item: 'journal',
    status: 'Hello'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710bd'),
    item: 'notebook',
    status: 'Hello'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710be'),
    item: 'paper',
    status: 'Hello'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710bf'),
    item: 'planner',
    status: 'Hello'
  },
  {
    _id: ObjectId('66cd308b3d125dbf642710c0'),
    item: 'postcard',
    status: 'Hello'
  }
]

...

Explicitly Exclude the _id Field
..................................
Note
Unless the _id field is explicitly excluded in the projection document _id: 0, the _id field is returned.

The following operation finds documents in the bios collection and returns only the name field and the contribs field:

db.bios.find(
   { },
   { name: 1, contribs: 1, _id: 0 }
)

..............

Use Aggregation Expression:
...........................

Use Aggregation Expression
db.collection.find() projection can accept aggregation expressions and syntax.

With the use of aggregation expressions and syntax, you can project new fields or project existing fields with new values. For example, the following operation uses aggregation expressions to override the value of the name and awards fields as well as to include new fields reportDate, reportBy, and reportNumber.

db.bios.find(
   { },
   {
     _id: 0,
     name: {
        $concat: [
           { $ifNull: [ "$name.aka", "$name.first" ] },
           " ",
           "$name.last"
        ]
     },
     birth: 1,
     contribs: 1,
     awards: { $cond: { if: { $isArray: "$awards" }, then: { $size: "$awards" }, else: 0 } },
     reportDate: { $dateToString: {  date: new Date(), format: "%Y-%m-%d" } },
     reportBy: "subu",
     reportNumber: { $literal: 1 }
   }
)

Sample output:
[
  {
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    name: 'John Backus',
    awards: 4,
    reportDate: '2024-08-27',
    reportBy: 'hellouser123',
    reportNumber: 1
  }
]
....................................................................................
			  Cursors
....................................................................................
In MongoDB, a cursor is a pointer to the result set of a query. When you execute a find operation, MongoDB returns a cursor that allows you to iterate over the documents in the result set. 

In mongosh, if the returned cursor is not assigned to a variable using the var keyword, the cursor is automatically iterated to access up to the first 20 documents that match the query. You can update the displayBatchSize variable to change the number of automatically iterated documents.

The following example sets the batch size to 3. Future db.collection.find() operations will only return 3 documents per cursor iteration.

config.set( "displayBatchSize", 3 )

To manually iterate over the results, assign the returned cursor to a variable with the var keyword, as shown in the following sections.

mydb> config.set( "displayBatchSize", 3 )
Setting "displayBatchSize" has been changed
mydb> db.bios.find( {}, { _id: 0, name: { $concat: [ { $ifNull: ["$name.aka", "$name.first"] }, " ", "$name.last"] }, birth: 1, contribs: 1, awards: { $cond: { if: { $isArray: "$awards" }, then: { $size: "$awards" }, else: 0 } }, reportDate: { $dateToString: { date: new Date(), format: "%Y-%m-%d" } }, reportBy: "hellouser123", reportNumber: { $literal: 1 } } )
[
  {
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    name: 'John Backus',
    awards: 4,
    reportDate: '2024-08-27',
    reportBy: 'hellouser123',
    reportNumber: 1
  },
  {
    birth: ISODate('1927-09-04T04:00:00.000Z'),
    contribs: [ 'Lisp', 'Artificial Intelligence', 'ALGOL' ],
    name: 'John McCarthy',
    awards: 3,
    reportDate: '2024-08-27',
    reportBy: 'hellouser123',
    reportNumber: 1
  },
  {
    birth: ISODate('1906-12-09T05:00:00.000Z'),
    contribs: [ 'UNIVAC', 'compiler', 'FLOW-MATIC', 'COBOL' ],
    name: 'Grace Hopper',
    awards: 4,
    reportDate: '2024-08-27',
    reportBy: 'hellouser123',
    reportNumber: 1
  }
]

if you want rest of the documents.

mydb> it
[
  {
    birth: ISODate('1926-08-27T04:00:00.000Z'),
    contribs: [ 'OOP', 'Simula' ],
    name: 'Kristen Nygaard',
    awards: 3,
    reportDate: '2024-08-27',
    reportBy: 'hellouser123',
    reportNumber: 1
  },
  {
    birth: ISODate('1931-10-12T04:00:00.000Z'),
    contribs: [ 'OOP', 'Simula' ],
    name: 'Ole-Johan Dahl',
    awards: 3,
    reportDate: '2024-08-27',
    reportBy: 'hellouser123',
    reportNumber: 1
  },
  {
    birth: ISODate('1956-01-31T05:00:00.000Z'),
    contribs: [ 'Python' ],
    name: 'Guido van Rossum',
    awards: 2,
    reportDate: '2024-08-27',
    reportBy: 'hellouser123',
    reportNumber: 1
  }
]
Type "it" for more

mydb> var myCursor = db.bios.find( );

mydb>

mydb> myCursor
[
  {
    _id: 1,
    name: { first: 'John', last: 'Backus' },
    birth: ISODate('1924-12-03T05:00:00.000Z'),
    death: ISODate('2007-03-17T04:00:00.000Z'),
    contribs: [ 'Fortran', 'ALGOL', 'Backus-Naur Form', 'FP' ],
    awards: [
      {
        award: 'W.W. McDowell Award',
        year: 1967,
        by: 'IEEE Computer Society'
      },
      {
        award: 'National Medal of Science',
        year: 1975,
        by: 'National Science Foundation'
      },
      { award: 'Turing Award', year: 1977, by: 'ACM' },
      {
        award: 'Draper Prize',
        year: 1993,
        by: 'National Academy of Engineering'
      }
    ]
  },
  {
    _id: ObjectId('51df07b094c6acd67e492f41'),
    name: { first: 'John', last: 'McCarthy' },
    birth: ISODate('1927-09-04T04:00:00.000Z'),
    death: ISODate('2011-12-24T05:00:00.000Z'),
    contribs: [ 'Lisp', 'Artificial Intelligence', 'ALGOL' ],
    awards: [
      { award: 'Turing Award', year: 1971, by: 'ACM' },
      { award: 'Kyoto Prize', year: 1988, by: 'Inamori Foundation' },
      {
        award: 'National Medal of Science',
        year: 1990,
        by: 'National Science Foundation'
      }
    ]
  },
  {
    _id: 3,
    name: { first: 'Grace', last: 'Hopper' },
    title: 'Rear Admiral',
    birth: ISODate('1906-12-09T05:00:00.000Z'),
    death: ISODate('1992-01-01T05:00:00.000Z'),
    contribs: [ 'UNIVAC', 'compiler', 'FLOW-MATIC', 'COBOL' ],
    awards: [
      {
        award: 'Computer Sciences Man of the Year',
        year: 1969,
        by: 'Data Processing Management Association'
      },
      {
        award: 'Distinguished Fellow',
        year: 1973,
        by: ' British Computer Society'
      },
      {
        award: 'W. W. McDowell Award',
        year: 1976,
        by: 'IEEE Computer Society'
      },
      {
        award: 'National Medal of Technology',
        year: 1991,
        by: 'United States'
      }
    ]
  }
]
Type "it" for more

With next() Method
The following example uses the cursor method next() to access the documents:

var myCursor = db.bios.find( );
var myDocument = myCursor.hasNext() ? myCursor.next() : null;
if (myDocument) {
    var myName = myDocument.name;
    print (tojson(myName));
}

To print, you can also use the printjson() method instead of print(tojson()):

if (myDocument) {
   var myName = myDocument.name;
   printjson(myName);
}

With forEach() Method
The following example uses the cursor method forEach() to iterate the cursor and access the documents:

var myCursor = db.bios.find( );
myCursor.forEach(printjson);


Modify the Cursor Behavior
.........................

Order Documents in the Result Set
The sort() method orders the documents in the result set. The following operation returns documents in the bios collection sorted in ascending order by the name field:

db.bios.find().sort( { name: 1 } )

sort() corresponds to the ORDER BY statement in SQL.

Cursor Methods
Here are some useful cursor methods:

cursor.limit(n): Limits the number of documents returned.
cursor.sort({ field: 1 }): Sorts the documents by the specified field.
cursor.skip(n): Skips the first n documents.
cursor.count(): Returns the number of documents in the cursor.
cursor.toArray(): Converts the cursor to an array.
cursor.close(): Closes the cursor and frees associated resources.


Combine Cursor Methods:

The following statements chain cursor methods limit() and sort():

db.bios.find().sort( { name: 1 } ).limit( 5 )
db.bios.find().limit( 5 ).sort( { name: 1 } )
.....................................................................................
		Query on Embedded/Nested Documents

db.inventory.insertMany( [
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "A" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },

   { item: "planner", qty: 75, siSpecify Equality Match on a Nested Field


The following example selects all documents where the field uom nested in the size field equals "in":

db.inventory.find( { "size.uom": "in" } )


ze: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" }
]);

Query on Nested Field with Dot Notation
........................................

To specify a query condition on fields in an embedded/nested document, use dot notation ("field.nestedField").

Note
When querying using dot notation, the field and nested field must be inside quotation marks.

Specify Match using Query Operator
A query filter document can use the query operators to specify conditions in the following form:

{ <field1>: { <operator1>: <value1> }, ... }


The following query uses the less than operator ($lt) on the field h embedded in the size field:

db.inventory.find( { "size.h": { $lt: 15 } } )


Specify AND Condition
The following query selects all documents where the nested field h is less than 15, the nested field uom equals "in", and the status field equals "D":

db.inventory.find( { "size.h": { $lt: 15 }, "size.uom": "in", status: "D" } )


Warning
MongoDB does not recommend comparisons on embedded documents because the operations require an exact match of the specified <value> document, including the field order.

For example, the following query does not match any documents in the inventory collection:

db.inventory.find(  { size: { w: 21, h: 14, uom: "cm" } }  )


Queries that use comparisons on embedded documents can result in unpredictable behavior when used with a driver that does not use ordered data structures for expressing queries.
.....................................................................................
			Projection with Nested Fields

myDb> db.bios.find( {}, {name:{first:1}})
[
  { _id: 1, name: { first: 'John' } },
  {
    _id: ObjectId('51df07b094c6acd67e492f41'),
    name: { first: 'John' }
  },
  { _id: 3, name: { first: 'Grace' } },
  { _id: 4, name: { first: 'Kristen' } },
  { _id: 5, name: { first: 'Ole-Johan' } },
  { _id: 6, name: { first: 'Guido' } },
  {
    _id: ObjectId('51e062189c6ae665454e301d'),
    name: { first: 'Dennis' }
  },
  { _id: 8, name: { first: 'Yukihiro' } },
  { _id: 9, name: { first: 'James' } },
  { _id: 10, name: { first: 'Martin' } }
]


....................................................................................
			 Arrays Matching -Query
...................................................................................

Mock data:

db.inventory.insertMany([
   { item: "journal", qty: 25, tags: ["blank", "red"], dim_cm: [ 14, 21 ] },
   { item: "notebook", qty: 50, tags: ["red", "blank"], dim_cm: [ 14, 21 ] },
   { item: "paper", qty: 100, tags: ["red", "blank", "plain"], dim_cm: [ 14, 21 ] },
   { item: "planner", qty: 75, tags: ["blank", "red"], dim_cm: [ 22.85, 30 ] },
   { item: "postcard", qty: 45, tags: ["blue"], dim_cm: [ 10, 15.25 ] }
]);
To specify equality condition on an array, use the query document { <field>: <value> } where <value> is the exact array to match, including the order of the elements.

The following example queries for all documents where the field tags value is an array with exactly two elements, "red" and "blank", in the specified order:

myDb> db.inventory.find( { tags: ["red", "blank"] } )
[
  {
    _id: ObjectId('66cdcc7e14b2342a562710cc'),
    item: 'notebook',
    qty: 50,
    tags: [ 'red', 'blank' ],
    dim_cm: [ 14, 21 ]
  }
]

If, instead, you wish to find an array that contains both the elements "red" and "blank", without regard to order or other elements in the array, use the $all operator:

db.inventory.find( { tags: { $all: ["red", "blank"] } } )


Query an Array for an Element
..............................

To query if the array field contains at least one element with the specified value, use the filter { <field>: <value> } where <value> is the element value.

The following example queries for all documents where tags is an array that contains the string "red" as one of its elements:

myDb> db.inventory.find( { tags: "red" } )
[
  {
    _id: ObjectId('66cdcc7e14b2342a562710cb'),
    item: 'journal',
    qty: 25,
    tags: [ 'blank', 'red' ],
    dim_cm: [ 14, 21 ]
  },
  {
    _id: ObjectId('66cdcc7e14b2342a562710cc'),
    item: 'notebook',
    qty: 50,
    tags: [ 'red', 'blank' ],
    dim_cm: [ 14, 21 ]
  },
  {
    _id: ObjectId('66cdcc7e14b2342a562710cd'),
    item: 'paper',
    qty: 100,
    tags: [ 'red', 'blank', 'plain' ],
    dim_cm: [ 14, 21 ]
  },
  {
    _id: ObjectId('66cdcc7e14b2342a562710ce'),
    item: 'planner',
    qty: 75,
    tags: [ 'blank', 'red' ],
    dim_cm: [ 22.85, 30 ]
  }
]
.....................................................................................

To specify conditions on the elements in the array field, use query operators in the query filter document:

{ <array field>: { <operator1>: <value1>, ... } }


For example, the following operation queries for all documents where the array dim_cm contains at least one element whose value is greater than 25.

myDb> db.inventory.find( { dim_cm: { $gt: 25 } } )
[
  {
    _id: ObjectId('66cdcc7e14b2342a562710ce'),
    item: 'planner',
    qty: 75,
    tags: [ 'blank', 'red' ],
    dim_cm: [ 22.85, 30 ]
  }
]
...................................................................................

Query an Array by Array Length
Use the $size operator to query for arrays by number of elements. For example, the following selects documents where the array tags has 3 elements.

db.inventory.find( { "tags": { $size: 3 } } )

.................

Query for an Element by the Array Index Position
..................................................

Using dot notation, you can specify query conditions for an element at a particular index or position of the array. The array uses zero-based indexing.

Note
When querying using dot notation, the field and nested field must be inside quotation marks.

The following example queries for all documents where the second element in the array dim_cm is greater than 25:

db.inventory.find( { "dim_cm.1": { $gt: 25 } } )

.....................................................................................
		Query an Array of Embedded Documents

Mock data:
db.inventory.insertMany( [
   { item: "journal", instock: [ { warehouse: "A", qty: 5 }, { warehouse: "C", qty: 15 } ] },
   { item: "notebook", instock: [ { warehouse: "C", qty: 5 } ] },
   { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 15 } ] },
   { item: "planner", instock: [ { warehouse: "A", qty: 40 }, { warehouse: "B", qty: 5 } ] },
   { item: "postcard", instock: [ { warehouse: "B", qty: 15 }, { warehouse: "C", qty: 35 } ] }
]);

Query for a Document Nested in an Array:

The following example selects all documents where an element in the instock array matches the specified document:

myDb> db.inventory.find( { "instock": { warehouse: "A", qty: 5 } } )
[
  {
    _id: ObjectId('66cde11114b2342a562710d0'),
    item: 'journal',
    instock: [ { warehouse: 'A', qty: 5 }, { warehouse: 'C', qty: 15 } ]
  }
]

Equality matches on the whole embedded/nested document require an exact match of the specified document, including the field order. For example, the following query does not match any documents in the inventory collection:

db.inventory.find( { "instock": { qty: 5, warehouse: "A" } } )
................

Specify a Query Condition on a Field in an Array of Documents:
..............................................................

Specify a Query Condition on a Field Embedded in an Array of Documents
If you do not know the index position of the document nested in the array, concatenate the name of the array field, with a dot (.) and the name of the field in the nested document.

The following example selects all documents where the instock array has at least one embedded document that contains the field qty whose value is less than or equal to 20:

db.inventory.find( { 'instock.qty': { $lte: 20 } } )

db.inventory.find( { "instock.qty": 5, "instock.warehouse": "A" } )

db.inventory.find( { "instock.qty": { $gt: 10,  $lte: 20 } } )
.................................................................................
		Query for Null or Missing Fields


db.inventory.insertMany([
   { _id: 1, item: null },
   { _id: 2 }
])

Equality Filter
The { item : null } query matches documents that either contain the item field whose value is null or that do not contain the item field.

Equality Filter
The { item : null } query matches documents that either contain the item field whose value is null or that do not contain the item field.

db.inventory.find( { item: null } )
[ { _id: 1, item: null }, { _id: 2 } ]


The query returns both documents in the collection.

Non-Equality Filter
To query for fields that exist and are not null, use the { $ne : null } filter. The { item : { $ne : null } } query matches documents where the item field exists and has a non-null value.

db.inventory.find( { item: { $ne : null } } )


Type Check
The { item : { $type: 10 } } query matches only documents that contain the item field whose value is null; i.e. the value of the item field is of BSON Type Null (BSON Type 10):

db.inventory.find( { item : { $type: 10 } } )


The query returns only the document where the item field has a value of null.
................

Existence Check
The following example queries for documents that do not contain a field. [1]

The { item : { $exists: false } } query matches documents that do not contain the item field:

db.inventory.find( { item : { $exists: false } } )


The query only returns the document that does not contain the item field.
.....................................................................................
			Aggregation
....................................................................................

Aggregation in MongoDB is a way to process data records and return computed results. It allows users to transform data more powerfully than the find() command by using multiple stages and expressions to build a pipeline of operations on their data. The aggregation pipeline runs in the MongoDB server and can be optimized before running


MongoDB Aggregation is a powerful database process that allows you to perform complex data transformations and computations on collections of documents or rows. Here are the key points:

Aggregation Pipelines:
......................

1.Aggregation pipelines are the preferred method for performing aggregations in MongoDB.
2.A pipeline consists of one or more stages that process documents sequentially.
3.Each stage performs an operation on the input documents (e.g., filtering, grouping, calculating values).
4.The output from one stage becomes the input for the next stage.
5.You can use aggregation pipelines to:
    5.1.Group values from multiple documents together.
    5.2.Perform operations on grouped data to return a single result.  
    5.3.Analyze data changes over time.


To perform aggregation operations, you can use:

Aggregation pipelines, which are the preferred method for performing aggregations.

Single purpose aggregation methods, which are simple but lack the capabilities of an aggregation pipeline.


eg:
Mock data:
db.orders.insertMany( [
   { _id: 0, name: "Pepperoni", size: "small", price: 19,
     quantity: 10, date: ISODate( "2021-03-13T08:14:30Z" ) },
   { _id: 1, name: "Pepperoni", size: "medium", price: 20,
     quantity: 20, date : ISODate( "2021-03-13T09:13:24Z" ) },
   { _id: 2, name: "Pepperoni", size: "large", price: 21,
     quantity: 30, date : ISODate( "2021-03-17T09:22:12Z" ) },
   { _id: 3, name: "Cheese", size: "small", price: 12,
     quantity: 15, date : ISODate( "2021-03-13T11:21:39.736Z" ) },
   { _id: 4, name: "Cheese", size: "medium", price: 13,
     quantity:50, date : ISODate( "2022-01-12T21:23:13.331Z" ) },
   { _id: 5, name: "Cheese", size: "large", price: 14,
     quantity: 10, date : ISODate( "2022-01-12T05:08:13Z" ) },
   { _id: 6, name: "Vegan", size: "small", price: 17,
     quantity: 10, date : ISODate( "2021-01-13T05:08:13Z" ) },
   { _id: 7, name: "Vegan", size: "medium", price: 18,
     quantity: 10, date : ISODate( "2021-01-13T05:10:13Z" ) }
] )


db.orders.aggregate( [

   // Stage 1: Filter pizza order documents by pizza size
   {
      $match: { size: "medium" }
   },

   // Stage 2: Group remaining documents by pizza name and calculate total quantity
   {
      $group: { _id: "$name", totalQuantity: { $sum: "$quantity" } }
   }

] )

$group:
......
$group (aggregation)

The $group stage separates documents into groups according to a "group key". The output is one document for each unique group key.

A group key is often a field, or group of fields. The group key can also be the result of an expression. Use the _id field in the $group pipeline stage to set the group key. See below for usage examples.

In the $group stage output, the _id field is set to the group key for that document.

Syntax:
{
 $group:
   {
     _id: <expression>, // Group key
     <field1>: { <accumulator1> : <expression1> },
     ...
   }
 }

Examples:
Count the Number of Documents in a Collection

MockData:
db.sales.insertMany([
  { "_id" : 1, "item" : "abc", "price" : Decimal128("10"), "quantity" : Int32("2"), "date" : ISODate("2014-03-01T08:00:00Z") },
  { "_id" : 2, "item" : "jkl", "price" : Decimal128("20"), "quantity" : Int32("1"), "date" : ISODate("2014-03-01T09:00:00Z") },
  { "_id" : 3, "item" : "xyz", "price" : Decimal128("5"), "quantity" : Int32( "10"), "date" : ISODate("2014-03-15T09:00:00Z") },
  { "_id" : 4, "item" : "xyz", "price" : Decimal128("5"), "quantity" :  Int32("20") , "date" : ISODate("2014-04-04T11:21:39.736Z") },
  { "_id" : 5, "item" : "abc", "price" : Decimal128("10"), "quantity" : Int32("10") , "date" : ISODate("2014-04-04T21:23:13.331Z") },
  { "_id" : 6, "item" : "def", "price" : Decimal128("7.5"), "quantity": Int32("5" ) , "date" : ISODate("2015-06-04T05:08:13Z") },
  { "_id" : 7, "item" : "def", "price" : Decimal128("7.5"), "quantity": Int32("10") , "date" : ISODate("2015-09-10T08:43:00Z") },
  { "_id" : 8, "item" : "abc", "price" : Decimal128("10"), "quantity" : Int32("5" ) , "date" : ISODate("2016-02-06T20:20:13Z") },
])

db.sales.aggregate( [
  {
    $group: {
       _id: null,
       count: { $count: { } }
    }
  }
] )

The operation returns the following result:

{ "_id" : null, "count" : 8 }

This aggregation operation is equivalent to the following SQL statement:

SELECT COUNT(*) AS count FROM sales
..........

Retrieve Distinct Values
The following aggregation operation uses the $group stage to retrieve the distinct item values from the sales collection:

db.sales.aggregate( [ { $group : { _id : "$item" } } ] )

Group by Item Having
The following aggregation operation groups documents by the item field, calculating the total sale amount per item and returning only the items with total sale amount greater than or equal to 100:

db.sales.aggregate(
  [
    // First Stage
    {
      $group :
        {
          _id : "$item",
          totalSaleAmount: { $sum: { $multiply: [ "$price", "$quantity" ] } }
        }
     },
     // Second Stage
     {
       $match: { "totalSaleAmount": { $gte: 100 } }
     }
   ]
 )

First Stage:
The $group stage groups the documents by item to retrieve the distinct item values. This stage returns the totalSaleAmount for each item.
Second Stage:
The $match stage filters the resulting documents to only return items with a totalSaleAmount greater than or equal to 100.
The operation returns the following result:

{ "_id" : "abc", "totalSaleAmount" : Decimal128("170") }
{ "_id" : "xyz", "totalSaleAmount" : Decimal128("150") }
{ "_id" : "def", "totalSaleAmount" : Decimal128("112.5") }
This aggregation operation is equivalent to the following SQL statement:

SELECT item,
   Sum(( price * quantity )) AS totalSaleAmount
FROM   sales
GROUP  BY item
HAVING totalSaleAmount >= 100

https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/#std-label-ex-agg-group-stage
....................................................................................

SQL to Monogdb Mapping:
WHERE
$match

GROUP BY
$group

HAVING
$match

SELECT
$project

ORDER BY
$sort

LIMIT
$limit

SUM()
$sum

COUNT()
$sum
$sortByCount

join
$lookup

SELECT INTO NEW_TABLE
$out

MERGE INTO TABLE
$merge

UNION ALL

$unionWith

https://www.mongodb.com/docs/manual/reference/sql-aggregation-comparison/

Advnced Example:
Sample Data Population
Drop any old version of the database (if it exists) and then populate a new persons collection with 6 person documents:


db = db.getSiblingDB("book-filtered-top-subset");
db.dropDatabase();

// Create an index for a persons collection
db.persons.createIndex({"vocation": 1, "dateofbirth": 1});

// Insert records into the persons collection
db.persons.insertMany([
  {
    "person_id": "6392529400",
    "firstname": "Elise",
    "lastname": "Smith",
    "dateofbirth": ISODate("1972-01-13T09:32:07Z"),
    "vocation": "ENGINEER",
    "address": { 
        "number": 5625,
        "street": "Tipa Circle",
        "city": "Wojzinmoj",
    },
  },
  {
    "person_id": "1723338115",
    "firstname": "Olive",
    "lastname": "Ranieri",
    "dateofbirth": ISODate("1985-05-12T23:14:30Z"),    
    "gender": "FEMALE",
    "vocation": "ENGINEER",
    "address": {
        "number": 9303,
        "street": "Mele Circle",
        "city": "Tobihbo",
    },
  },
  {
    "person_id": "8732762874",
    "firstname": "Toni",
    "lastname": "Jones",
    "dateofbirth": ISODate("1991-11-23T16:53:56Z"),    
    "vocation": "POLITICIAN",
    "address": {
        "number": 1,
        "street": "High Street",
        "city": "Upper Abbeywoodington",
    },
  },
  {
    "person_id": "7363629563",
    "firstname": "Bert",
    "lastname": "Gooding",
    "dateofbirth": ISODate("1941-04-07T22:11:52Z"),    
    "vocation": "FLORIST",
    "address": {
        "number": 13,
        "street": "Upper Bold Road",
        "city": "Redringtonville",
    },
  },
  {
    "person_id": "1029648329",
    "firstname": "Sophie",
    "lastname": "Celements",
    "dateofbirth": ISODate("1959-07-06T17:35:45Z"),    
    "vocation": "ENGINEER",
    "address": {
        "number": 5,
        "street": "Innings Close",
        "city": "Basilbridge",
    },
  },
  {
    "person_id": "7363626383",
    "firstname": "Carl",
    "lastname": "Simmons",
    "dateofbirth": ISODate("1998-12-26T13:13:55Z"),    
    "vocation": "ENGINEER",
    "address": {
        "number": 187,
        "street": "Hillside Road",
        "city": "Kenningford",
    },
  },
]);


var pipeline = [
  // Match engineers only
  {"$match": {
    "vocation": "ENGINEER",
  }},
    
  // Sort by youngest person first
  {"$sort": {
    "dateofbirth": -1,
  }},      
    
  // Only include the first 3 youngest people
  {"$limit": 3},  

  // Exclude unrequired fields from each person record
  {"$unset": [
    "_id",
    "vocation",
    "address",
  ]},    
];

db.persons.aggregate(pipeline);

https://www.practical-mongodb-aggregations.com/examples/joining/one-to-one-join.html
............................***************.........................................
			  Update
..............................................................................
		
in order to update , we have following methods

Collection.updateOne()
Collection.updateMany()
Collection.replaceOne()	

Mock Data
db.inventory.insertMany( [
   { item: "canvas", qty: 100, size: { h: 28, w: 35.5, uom: "cm" }, status: "A" },
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "mat", qty: 85, size: { h: 27.9, w: 35.5, uom: "cm" }, status: "A" },
   { item: "mousepad", qty: 25, size: { h: 19, w: 22.85, uom: "cm" }, status: "P" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "P" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" },
   { item: "sketchbook", qty: 80, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "sketch pad", qty: 95, size: { h: 22.85, w: 30.5, uom: "cm" }, status: "A" }
] );

Update Documents in a Collection
  To update a document, MongoDB provides update operators, such as $set, to modify field values.

  To use the update operators, pass to the update methods an update document of the form:

{
  <update operator>: { <field1>: <value1>, ... },
  <update operator>: { <field2>: <value2>, ... },
  ...
}

Some update operators, such as $set, will create the field if the field does not exist.

Update a Single Document :

The following example uses the db.collection.updateOne() method on the inventory collection to update the first document where item equals "paper":

db.collection.updateOne(filter, update, options)

filter:
 The selection criteria for the update. The same query selectors as in the find()  method are available.

Specify an empty document { } to update the first document returned in the collection.

update:
  The modifications to apply. Can be one of the following:

  Update document  -  Contains only update operator expressions.

Aggregation pipeline - Contains only the following aggregation stages:

 $addFields and its alias $set
 $project and its alias $unset
 $replaceRoot and its alias $replaceWith.


options:
  There are lot of options , we will see only few options

upsert  boolean
{upsert:true or false}

Optional. When true, updateOne() either:

1.Creates a new document if no documents match the filter. 
2.Updates a single document that matches the filter.
3.To avoid multiple upserts, ensure that the filter field(s) are uniquely indexed.
 Defaults to false, which does not insert a new document when no match is found.


myDb> db.inventory.updateOne(
...    { item: "paper" },
...    {
...      $set: { "size.uom": "cm", status: "P" },
...      $currentDate: { lastModified: true }
...    }
... )
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}

The update operation:

1.uses the $set operator to update the value of the size.uom field to "cm" and the value of the status field to "P",
2.uses the $currentDate operator to update the value of the lastModified field to the current date. If lastModified field does not exist, $currentDate will create the field. 
..................................................

Update Multiple Documents:
.........................
Update Multiple Documents
The following example uses the db.collection.updateMany() method on the inventory collection to update all documents where qty is less than 50:

myDb> db.inventory.updateMany(
...    { "qty": { $lt: 50 } },
...    {
...      $set: { "size.uom": "in", status: "P" },
...      $currentDate: { lastModified: true }
...    }
... );
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 3,
  modifiedCount: 3,
  upsertedCount: 0
}

Replace a Document
To replace the entire content of a document except for the _id field, pass an entirely new document as the second argument to db.collection.replaceOne().

When replacing a document, the replacement document must consist of only field/value pairs. The replacement document cannot include update operators expressions.

The replacement document can have different fields from the original document. In the replacement document, you can omit the _id field since the _id field is immutable. However, if you do include the _id field, it must have the same value as the current value.

The following example replaces the first document from the inventory collection where item: "paper":

db.inventory.replaceOne(
   { item: "paper" },
   { item: "paper", instock: [ { warehouse: "A", qty: 60 }, { warehouse: "B", qty: 40 } ] }
)
....................................................................................
			  Remove -Delete Documents
...................................................................................
db.collection.deleteOne(filter)
Delete at most a single document that match a specified filter even though multiple documents may match the specified filter.
db.collection.deleteMany()
Delete all documents that match a specified filter.
db.collection.remove()
Delete a single document or all documents that match a specified filter.


Mock Data:
db.inventory.insertMany( [
   { item: "journal", qty: 25, size: { h: 14, w: 21, uom: "cm" }, status: "A" },
   { item: "notebook", qty: 50, size: { h: 8.5, w: 11, uom: "in" }, status: "P" },
   { item: "paper", qty: 100, size: { h: 8.5, w: 11, uom: "in" }, status: "D" },
   { item: "planner", qty: 75, size: { h: 22.85, w: 30, uom: "cm" }, status: "D" },
   { item: "postcard", qty: 45, size: { h: 10, w: 15.25, uom: "cm" }, status: "A" },
] );

Delete Only One Document that Matches a Condition
To delete at most a single document that matches a specified filter (even though multiple documents may match the specified filter) use the db.collection.deleteOne() method.

The following example deletes the first document where status is "D":

db.inventory.deleteOne( { status: "D" } )


Delete ManY:
Delete All Documents that Match a Condition
You can specify criteria, or filters, that identify the documents to delete. The filters use the same syntax as read operations.

To specify equality conditions, use <field>:<value> expressions in the query filter document:

{ <field1>: <value1>, ... }


A query filter document can use the query operators to specify conditions in the following form:

{ <field1>: { <operator1>: <value1> }, ... }


To delete all documents that match a deletion criteria, pass a filter parameter to the deleteMany() method.

The following example removes all documents from the inventory collection where the status field equals "A":

db.inventory.deleteMany({ status : "A" })
.....................................................................................
			Bulk Operations
....................................................................................

MongoDB provides clients the ability to perform write operations in bulk. Bulk write operations affect a single collection. MongoDB allows applications to determine the acceptable level of acknowledgment required for bulk write operations.

The db.collection.bulkWrite() method provides the ability to perform bulk insert, update, and delete operations.

MongoDB also supports bulk insert through the db.collection.insertMany() method.

bulkWrite() Methods

bulkWrite() supports the following write operations:

insertOne
updateOne
updateMany
replaceOne
deleteOne
deleteMany

Mock data:
db.pizzas.insertMany( [
   { _id: 0, type: "pepperoni", size: "small", price: 4 },
   { _id: 1, type: "cheese", size: "medium", price: 7 },
   { _id: 2, type: "vegan", size: "large", price: 8 }
] )

The following bulkWrite() example runs these operations on the pizzas collection:

Adds two documents using insertOne.

Updates a document using updateOne.

Deletes a document using deleteOne.

Replaces a document using replaceOne.

try {
   db.pizzas.bulkWrite( [
      { insertOne: { document: { _id: 3, type: "beef", size: "medium", price: 6 } } },
      { insertOne: { document: { _id: 4, type: "sausage", size: "large", price: 10 } } },
      { updateOne: {
         filter: { type: "cheese" },
         update: { $set: { price: 8 } }
      } },
      { deleteOne: { filter: { type: "pepperoni"} } },
      { replaceOne: {
         filter: { type: "vegan" },
         replacement: { type: "tofu", size: "small", price: 4 }
      } }
   ] )
} catch( error ) {
   print( error )
}
....................................................................................
			 Indexes
...................................................................................

Purpose of Indexes:
Indexes allow efficient querying and retrieval of documents from a collection.
Without indexes, MongoDB would need to scan every document in a collection to return query results.
When an appropriate index exists for a query, MongoDB uses it to limit the number of documents it must scan.

Indexes in MongoDB are special data structures that store a portion of the collection’s data set in an easy-to-traverse form. They play a crucial role in improving query performance by providing quick access to data based on indexed fields


Types of Indexes:
Single Field Index: Created on a single field (e.g., employee ID, location).
Compound Index: Combines multiple fields (e.g., item and quantity) for more complex queries.
Index on Embedded Documents: Useful when querying entire embedded objects.
Geospatial Index: Supports geospatial queries based on location data.

Trade-offs:
While indexes improve query performance, adding an index impacts write operations.
For collections with a high write-to-read ratio, indexes can be expensive due to additional updates during inserts.


Single-Field Index: To create an index on a single field, use the createIndex method. For example, to create an ascending index on the employee_id field in a collection named employees, run the following command:

Example:

 without Index:
myDb> db.inventory.find({item:'postcard'}).explain("executionStats")
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'myDb.inventory',
    indexFilterSet: false,
    parsedQuery: { item: { '$eq': 'postcard' } },
    queryHash: '8098DE55',
    planCacheKey: '8098DE55',
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    winningPlan: {
      stage: 'COLLSCAN',
      filter: { item: { '$eq': 'postcard' } },
      direction: 'forward'
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 1,
    executionTimeMillis: 0,
    totalKeysExamined: 0,
    totalDocsExamined: 5,
    executionStages: {
      stage: 'COLLSCAN',
      filter: { item: { '$eq': 'postcard' } },
      nReturned: 1,
      executionTimeMillisEstimate: 0,
      works: 6,
      advanced: 1,
      needTime: 4,
      needYield: 0,
      saveState: 0,
      restoreState: 0,
      isEOF: 1,
      direction: 'forward',
      docsExamined: 5
    }
  },
  command: { find: 'inventory', filter: { item: 'postcard' }, '$db': 'myDb' },
  serverInfo: {
    host: 'DESKTOP-KAUFCR7',
    port: 27017,
    version: '7.0.12',
    gitVersion: 'b6513ce0781db6818e24619e8a461eae90bc94fc'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600,
    internalQueryFrameworkControl: 'trySbeRestricted'
  },
  ok: 1
}

it uses lenear search internally, if 1000 thousands of documents it takes so much time.

create Index on name:

db.inventory.createIndex({name:1})
value = 1 ascending order
value = - decending order

myDb> db.inventory.createIndex({item:1})
item_1
myDb> db.inventory.find({item:'postcard'}).explain("executionStats")
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'myDb.inventory',
    indexFilterSet: false,
    parsedQuery: { item: { '$eq': 'postcard' } },
    queryHash: '8098DE55',
    planCacheKey: 'BD68BBA1',
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    winningPlan: {
      stage: 'FETCH',
      inputStage: {
        stage: 'IXSCAN',
        keyPattern: { item: 1 },
        indexName: 'item_1',
        isMultiKey: false,
        multiKeyPaths: { item: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: { item: [ '["postcard", "postcard"]' ] }
      }
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 1,
    executionTimeMillis: 12,
    totalKeysExamined: 1,
    totalDocsExamined: 1,
    executionStages: {
      stage: 'FETCH',
      nReturned: 1,
      executionTimeMillisEstimate: 11,
      works: 2,
      advanced: 1,
      needTime: 0,
      needYield: 0,
      saveState: 1,
      restoreState: 1,
      isEOF: 1,
      docsExamined: 1,
      alreadyHasObj: 0,
      inputStage: {
        stage: 'IXSCAN',
        nReturned: 1,
        executionTimeMillisEstimate: 11,
        works: 2,
        advanced: 1,
        needTime: 0,
        needYield: 0,
        saveState: 1,
        restoreState: 1,
        isEOF: 1,
        keyPattern: { item: 1 },
        indexName: 'item_1',
        isMultiKey: false,
        multiKeyPaths: { item: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: { item: [ '["postcard", "postcard"]' ] },
        keysExamined: 1,
        seeks: 1,
        dupsTested: 0,
        dupsDropped: 0
      }
    }
  },
  command: { find: 'inventory', filter: { item: 'postcard' }, '$db': 'myDb' },
  serverInfo: {
    host: 'DESKTOP-KAUFCR7',
    port: 27017,
    version: '7.0.12',
    gitVersion: 'b6513ce0781db6818e24619e8a461eae90bc94fc'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600,
    internalQueryFrameworkControl: 'trySbeRestricted'
  },
  ok: 1
}


Compound Index:
...............

db.<collection>.createIndex( {
   <field1>: <sortOrder>,
   <field2>: <sortOrder>,
   ...
   <fieldN>: <sortOrder>
} )


Get All Indexs
myDb> db.inventory.getIndexes()
[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { item: 1 }, name: 'item_1' }
]

myDb> db.inventory.dropIndex("item_1")
{ nIndexesWas: 2, ok: 1 }
myDb> db.inventory.getIndexes()
[ { v: 2, key: { _id: 1 }, name: '_id_' } ]

