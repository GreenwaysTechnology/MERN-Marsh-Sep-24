			Node.js

What is node?
Why node?
Node.js Architecture
 -High level
 -low level

What is Node? /Node.js?
    Node is javascript runtime and platform.
By using node we can run js code outside browser

Why Node?
 ->Process
 ->Threading Models
 ->IO architecture

Process:
 It is program which runs the other program.
eg: CLR is process which runs .net code/app
    jvm is process which runs java code
    node is process which runs js code

Threading Model:
  Every process has thread.
 CLR AND JVM is multi threaded
   YOu can created threads, also runtimes hosts its own thread - main thread.

IO architecture:
  IO means read and write.

Node was to created to build "IO Applications"

Types of IO Applications

1.File system io apps
   app can read and write data from and to "hard disk"
2.Networking io apps
   Web server is io apps, which reads data from the network and sends data via       network.
   TCP server
   UDP Server
   Data gram server
3.Process IO/Memory
   read and write data from and into "RAM" 


Other languages also can help to implement IO Applications.
  .net 
     FileSystem name space to read and write data from disk
  .net 
     MVC architecture is used to read and write data from and to network

What is the core difference between other language and node.js with respect io?

			Non Blocking IO
.....................................................................................

File descriptor:
 file descriptor is c program (ds) which holds all io informations.

if a program is going to talk to keyword,monitor.
  fd holds the references to keyboard,monitor.


Linux non blocking apis

1.select -  2000
2.poll 
3.epoll - modern event notification api 


Linux is the first os who introduced nonblocking io apis

After Linux, Windows,mac, other BSD os also had introduced nonblocking apis

windows-iocp
linux -epoll
mac - kqueue
.....................................................................................
			 First Non blocking webserver


ngix webserver was the first non blocking webserver which was created and tested on linux.
.....................................................................................
			 Node.js as non blocking io wrapper
.....................................................................................

In 2007, Node.js was created to build non blocking io applications using javascript.

....................................................................................
			 Node.js non blocking arch


Node.js provides two major components

1.js runtime which is from google - V8
2.libuv runtime which is plaform abstraction lib for making non blocking io calls.

Node.js and threading model:
...........................

There are two threading model

1.non blocking thread /event loop threads/main thread

    - To handle non blocking network io calls

2.blocking thread/worker loop thread
      -To handle non blockig file io calls and blocking io calls, user code

....................................................................................
Node.js Programming area

1.Node REPL
2.Node and js apis
3.Node core apis
4.Styles of writing async programming
   ->Callback pattern
   ->Promise Pattern
   ->Promise with Async and await Pattern


...................................................................................

1.Node REPL - Read Evalulate Print loop

Node REPL is used to run js programs interactive mode.

Js programs are executed in two modes

1.interactive mode - REPL mode
2.script mode - by loading script on to the runtime
...................................................................................

1.Node REPL - Read Evalulate Print loop

Node REPL is used to run js programs interactive mode.

Js programs are executed in two modes

1.interactive mode - REPL mode
2.script mode - by loading script on to the runtime

1.interactive mode - REPL mode
C:\Users\subu>node
Welcome to Node.js v20.11.1.
Type ".help" for more information.
> 10 +10
20
> new Date()
2024-07-13T10:55:31.010Z
> JSON.stringify({id:1})
'{"id":1}'
> a=10
10
> b=20
20
> c = a + b
30
>

Can you use all js features inside node?

No

Browser objects such document,window,storage....

> window
Uncaught ReferenceError: window is not defined
>

In browser window is super object

In node what is super object?
  Process- Object
 process - it is variable holds Process object
 window - It is variable holds WIndow object

...

How to write js code and run on node?


Project setup:
G:\Marsh\nodejs>mkdir mynodeapp

G:\Marsh\nodejs>cd mynodeapp

G:\Marsh\nodejs\mynodeapp>mkdir src

G:\Marsh\nodejs\mynodeapp>code .


Helloworld:
...........

src/index.js
G:\Marsh\nodejs\mynodeapp>node src/index.js
Hello
.....................................................................................
		How to write async programming/non blocking programming in node
...................................................................................

Fundamental Requirement:
........................

1.OS should support non blocking apis like select,poll,epoll

2.Program languages/platforms also should provide high level apis to map os low level apis

3.In order to write non blocking apps in js(node), we have different patterns(styles)


Nonblocking Applications Developement style:
............................................

OS kernals sends events to application process(thread), now thread need to handle events,
in node js, events are handled in different ways

1.callbacks
2.Promises
3.Async await
4.reactive programming 

1.callbacks:
  Callback is listener function which gets registered during compile time
  and exexcuted during runtime when ever the event is emitted.

Req for async programming:
 
1.You need high level non blocking api - provided by node.js 
2.listener api which is called "function as parameter/hof" 

HOF functions are becoming listeners/callbacks which are called when ever event is emitted.

NonBlocking apis:
1.timer
   -setTimeout -
   -setInterval
2.io
   web
   fs
   socket
 etc...
3.process api
  nextTick


Now we are going to test non blocking feature with timers
..........................................................

Timers are not io apis but cpu related non blocking api.
How timers works , similar other non blocking apis also works.

Initally we will test with timer, and later we will see io apis step by step.


Use Case : Basic non blocking using timer:

function blockMe(message) {
    console.log(message)
}
function delay(listener) {
    //non blocking api which is called after some time which never blocks next line of code
    setTimeout(listener, 5000)
}

function main() {
    blockMe('start')
    delay(function () {
        console.log('hello,i am delayed')
    })
    blockMe('end')
}
main()

Use case: How to transfer data in to the caller
function blockMe(message) {
    console.log(message)
}
function delay(listener) {
    //non blocking api which is called after some time which never blocks next line of code
    setTimeout(listener, 5000,"Hello,I am delayed")
}

function main() {
    blockMe('start')
    delay(function (message) {
        console.log(message)
    })
    blockMe('end')
}
main()

Use case: Convert into arrow functions
function blockMe(message) {
    console.log(message)
}
function delay(listener) {
    //non blocking api which is called after some time which never blocks next line of code
    setTimeout(listener, 5000, "Hello,I am delayed")
}

function main() {
    blockMe('start')
    delay(message => console.log(message))
    blockMe('end')
}
main()

...................................................................................
			Callback Chaining /Callback composition
..................................................................................

Sequentional Programming:
.........................

result = apicall
result2  apicall(result)

The out put of one api call will be input to another api call -  chaining.

How to chain in nonblocking env?

//chaining
//resolve=success;reject=failure

const getUser = (resolve, reject) => {
    console.log('getUser is called')

    let user = {
        name: 'admin',
        password: 'admin'
    }
    //user = null
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, 'User Not Found')
    }

}
const login = (user, resolve, reject) => {
    console.log('Login is called')
    if (user.name === 'admin' && user.password === 'admin') {
        setTimeout(resolve, 1000, 'Login Success')
    } else {
        setTimeout(reject, 1000, 'Login Failed')
    }
}

const showDashboard = (status, resolve, reject) => {
    console.log('showDashboard is called')
    if (status === 'Login Success') {
        setTimeout(resolve, 1000, 'Welcome to dashboard')
    } else {
        setTimeout(reject, 1000, 'Sorry you are not valid user')
    }
}



function main() {
    getUser((user) => {
        //console.log(user)
        login(user, (status) => {
            //console.log(status)
            showDashboard(status, (message) => {
                console.log(message)
            }, (err) => {
                console.log(err)
            })
        }, (err) => {
            console.log(err)
        })

    }, (err) => {
        console.log(err)
    })
}
main()


....................................................................................
				Callback Hell
....................................................................................


function main() {
    getUser(user => {
        login(user, status => {
            showDashboard(status, (page) => {
                console.log(page)
            }, (err) => {
                console.log(err)
            })
        }, err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })

}
main()
....................

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

No
 "Callback Hell"

Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which   called as "Callback Hell".
..................................................................................
.....................................................................................
		IS There is better solution is available to write
			non blocking code
			without callbacks
....................................................................................

Yes!

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.

Solution:
 Promise

What is Promise?

 "Promise is design pattern" which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.

....................................................................................
			  Promise Implementation
.....................................................................................

Features of Promise Object:
1.Promise by deafult is Async. Which implements timer api with 0 ms .
2.Promise can be used with any async callback based  implementations.


Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.


Difference between callbacks and promises:

Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.

....................................................................................

		Promise Implemenation: Object Object creations
...................................................................................

1. Create Promise Object from Promise contructor
      new Promise()
2. Create Promise object from factory apis 
      Promise.resolve() / Promise.reject()


Promise object methods:

1.then - success
2.catch - errors
3.finally - clean up

factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

1.Promise factory api
   -success - resolve
   -failure - reject


//basic promise implementation:
//In promises , you dont need to pass function as parameter

Promise with Success and also ensure that Promise is async.
.....................................................................................

Use case: Promise with factory methods, default async.

Promise returns either success or failure.



function blockMe(message) {
    console.log(message)
}
function getSuccess() {
    return Promise.resolve('success')
}

function main() {
    blockMe('start')
    getSuccess().then(data => console.log(data))
    blockMe('end')
}
main()

Use case: Promise with failure 



function blockMe(message) {
    console.log(message)
}
function getFailure() {
    return Promise.reject('failed')
}

function main() {
    blockMe('start')
    getFailure().catch(err => console.log(err))
    blockMe('end')
}
main()

Use case : Promise with Either success or failure based on biz logic

//login

const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login Success')
    } else {
        return Promise.reject('Login failed')
    }
}

function main() {
    login('admin', 'admin')
        .then(status => console.log(status))
        .catch(err => console.log(err))

    login('bar', 'foo')
        .then(status => console.log(status))
        .catch(err => console.log(err))
}
main()
	..................................................................................
			2.Promise Constructor Api
....................................................................................

i want to return users after 1000ms

if i want to wrap any existing callback based program into promise based 

 "You have to use Promise Constructor Pattern"


function blockMe(message) {
    console.log(message)
}

const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        //wrap timer with promise using constructors
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, 'Login success')
        })
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, 'Login failed')
        })
    }
}

function main() {
    login('admin', 'admin')
        .then(status => console.log(status))
        .catch(err => console.log(err))

    login('bar', 'foo')
        .then(status => console.log(status))
        .catch(err => console.log(err))
}
main()
....................................................................................
			Async Composition,CallbackHell and Promises
....................................................................................


const getUser = () => {
    console.log('getUser is called')
    let user = {
        name: 'admin',
        password: 'admin'
    }
    //user = null
    if (user) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, user)
        })
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, 'User Not Found')
        })
    }

}
const login = user => {
    console.log('Login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'Login Success')
        } else {
            setTimeout(reject, 1000, 'Login Failed')
        }
    })
}

const showDashboard = status => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'Login Success') {
            setTimeout(resolve, 1000, 'Welcome to dashboard')
        } else {
            setTimeout(reject, 1000, 'Sorry you are not valid user')
        }
    })
}



function main() {
    // getUser((user) => {
    //     //console.log(user)
    //     login(user, (status) => {
    //         //console.log(status)
    //         showDashboard(status, (message) => {
    //             console.log(message)
    //         }, (err) => {
    //             console.log(err)
    //         })
    //     }, (err) => {
    //         console.log(err)
    //     })

    // }, (err) => {
    //     console.log(err)
    // })

    // getUser()
    //     .then(user => {
    //         //call login 
    //         return login(user)
    //     })
    //     .then(status => {
    //         //call show dashboard
    //         return showDashboard(status)
    //     })
    //     .then(message => {
    //         console.log(message)
    //     })
    //     .catch(err => {
    //         console.log(err)
    //     })

    getUser()
        .then(user => login(user))
        .then(status => showDashboard(status))
        .then(message => console.log(message))
        .catch(err => console.log(err))
}
main()
.....................................................................................
			Promise Hell and How to refactor
.....................................................................................
.....................................................................................
				Promise Hell
.....................................................................................

getUser()
        .then(user => login(user))
        .then(status => showdashboard(status)).then(page => console.log(page))
        .catch(err => console.log(err))

Here we are using many thens "thenables" which makes your code still complex to read,debug,maintain.

There is solution called "async ... await" keywords.
 Which does not replace promise rather , it simplfies to handle promises.

In order reduce thenables, ES 7 Introduced new key words to abstract promise then and catch are "async and await"

async keyword:

1.in front of function we use async keyword, meaning that the function returns promise by default with success only.



async function getValue() {
    return 10 // Promise.resolve(10)
}
function main() {
    const value = getValue()
    console.log(value)

    getValue().then(value=>console.log(value))
}
main()

await keyword:

 1.replace then and catch, make async code looks like sync code
 2.await keyword can be used only inside async functions.

eg:

//async keyword:
/**
 * 1.async keyword is used infront of function declaration
 * 2.by default async function return Promise with success data
 * 3.await keyword is used infront of function call which must return promise
 * 4.where ever we use await keyword that function must be marked async
 */

async function getValue() {
    //return 10 //Promise.resolve(10)
    return Promise.resolve(10)
}

async function main() {
    //console.log(getValue())
   // getValue().then(value => console.log(value))
   const value = await getValue()
   console.log(value)
}
main()

.............................................................................

async..with catch:


const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success')
    } else {
        return Promise.reject('Login Failed')
    }
}

async function main() {
    try {
        const status = await login('admin', 'admin')
        console.log(status)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.......................................................................

Login WIth async...await:

const login = (userName, password) => {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success') //Promise.resolve
    } else {
        return Promise.reject('Login Failed')
    }
}

async function main() {
    try {
        const status = await login('admin', 'admin')
        console.log(status)
    }
    catch (err) {
        console.log(err)
    }
    
}
main()

..................................................................................
			Promise chaining and async and await
....................................................................................


const getUser = () => {
    console.log('getUser is called')
    let user = {
        name: 'admin',
        password: 'admin'
    }
    //user = null
    if (user) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, user)
        })
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, 'User Not Found')
        })
    }

}
const login = user => {
    console.log('Login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'Login Success')
        } else {
            setTimeout(reject, 1000, 'Login Failed')
        }
    })
}

const showDashboard = status => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'Login Success') {
            setTimeout(resolve, 1000, 'Welcome to dashboard')
        } else {
            setTimeout(reject, 1000, 'Sorry you are not valid user')
        }
    })
}



async function main() {
    // getUser()
    //     .then(user => login(user))
    //     .then(status => showDashboard(status))
    //     .then(message => console.log(message))
    //     .catch(err => console.log(err))
    try {
        const user = await getUser()
        const status = await login(user)
        const message = await showDashboard(status)
        console.log(message, status, user)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
				Modules Pattern
...................................................................................


In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.mycom

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java

What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 

Module design patterns came.

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd:2005 on wards
4.ES 6 Module design pattern:2012-2015  = amd + cjs
------------------------------------------------------------
5.System :2007 = AMD = CJS + ES 6
6.UMD :2008 = NAMESPACE + AMD + CJS = ES 6

Two design patterns are used in coding:

3.CJS - Common JS =  namespace + amd:2005 on wards
4.ES 6 Module design pattern:2012-2015  = amd + cjs


cjs is default design pattern in node.js.
es6 module pattern also can be used in node.js

...................................................................................
				Commonjs-CJS
.....................................................................................

How to share code? How to import code?

 Code:
  Could be variables,functions,classes.
  Variables can have any literal string,numbers,boolean,objects,functions...

src
  |
  subfolders
|
index.js


Sharing code :

Keywords
exports
module.exports

Imporing code:

require('fileName')
require('folderName/fileName')

exports:
 Used to share more code from the single file.
 exports packs the entire code into one single js object and returns that object

exports default value is empty object.

Use case : how to link two files.

src/util.js
console.log('hello util')

src/index.js
//function
const result = require('./util')

console.log(result)

G:\Marsh\nodejs\moduleapp>node src/index.js
hello util
{}

Here you can see there is empty object, means that you have not shared any code.

Note:
 exports is just in built variable and its value by default is {} (empty object)

Use Case: How to share code using exports

src/util.js

// console.log('hello util')

//share code: variables,functions,array

exports.name = 'Subramaian'

G:\Marsh\nodejs\moduleapp>node src/index.js
{ name: 'Subramaian' }

src/util.js
exports.name = 'Subramaian'
exports.age = 44
exports.address = {
    city: 'Coimbatore'
}
exports.status = true
exports.skills = [{
    id: 1,
    name: 'js'
}]

G:\Marsh\nodejs\moduleapp>node src/index.js
{
  name: 'Subramaian',
  age: 44,
  address: { city: 'Coimbatore' },
  status: true,
  skills: [ { id: 1, name: 'js' } ]
}

//
//function
const result = require('./util')

console.log(result)

console.log(`Name ${result.name}`)
............................................................

module.exports

src/greeter.js

function sayGreet() {
    return 'Hello'
}

//share the function as it is
module.exports = sayGreet

src/services/todo.service.js


class TodoService {
    constructor() {
        console.log('todo service')
    }
    findAll() {
        return 'Todos'
    }
}
module.exports = TodoService

src/index.js
const result = require('./greeter')
const TodoService = require('./services/todo.service')

function main() {
    console.log(result)
    console.log(result())
    console.log(TodoService)
    let todoService = new TodoService()
    console.log(todoService.findAll())
}
main()

How to return Object?

Object can be class object, literal object,array.


class CustomerService {
    constructor() {
        console.log('CustomerService service')
    }
    findAll() {
        return 'customers'
    }
}
module.exports = new CustomerService()

Note:
Single file , Single class/Object/function/variable

Using module.exports , you cant export/share multiple things at time.

multiple module.exports or moudle.exports and exports inside single file not allowed.

src/data/customers.js

const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian'
},
{
    id: 2,
    name: 'Murugan'
},
{
    id: 3,
    name: 'Ram'
}

]
module.exports = CUSTOMERS

src/services/customer.service.js
const CUSTOMERS = require('../data/customers')

class CustomerService {
    constructor() {
        console.log('CustomerService service')
    }
    findAll() {
        return CUSTOMERS
    }
    save() {
        return 'save'
    }
    remove() {
        return 'delete'
    }
}
module.exports = new CustomerService()

src/index.js
const customerService = require('./services/customer.service')


function main() {
    console.log(customerService.findAll())
    console.log(customerService.save())
}
main()
.....................................................................................
			Async Programming and Modules
.....................................................................................

I have apis which encapsulated inside object(class), Those apis are async api.

Api design could be

1.callback based

2.Promise based

Who ever going to use Api

1.pass callback
2.get Promise and use then and catch
3.get Promise and use async, await.


steps:

Data
1.src/data/products.js

const PRODUCTS = [
    {
        id:1,
        name:'Phone',
        qty:100,
        price:12000
    },
    {
        id:2,
        name:'Watch',
        qty:33,
        price:4500
    }
]
module.exports = PRODUCTS

2.services- api

Types of api
1.sync api
2.async api
  -callback 
  -promise

sync api:
const PRDOUCTS = require('../data/products')

class ProductService {
    constructor() {
        console.log('Product Service initalized')
    }
    //apis
    getProducts() {
        return PRDOUCTS
    }
}
module.exports = new ProductService()

const productService = require('./services/product.service')

function main() {
    //call sync service
    console.log('start')
    const products = productService.getProducts()
    console.log(products)
    console.log('end')
}
main()
..................................
Async Api:

1.callback based:
.................
src/services/product.service.js
const PRDOUCTS = require('../data/products')

class ProductService {
    constructor() {
        console.log('Product Service initalized')
    }
    //async api with callback
    listProducts(resolve, reject) {
        if (PRDOUCTS) {
            setTimeout(resolve, 5000, PRDOUCTS)
        } else {
            setTimeout(reject, 5000, { message: 'Products Not Found' })

        }
    }
}
module.exports = new ProductService()


src/index.js
const productService = require('./services/product.service')

function main() {
    //call async service
    console.log('start')
    productService.listProducts(products => {
        console.log(products)
    }, err => {
        console.log(err)
    })
    console.log('end')
}
main()

Using Promises: with then and catch
....................................
src/services/products.js
const PRDOUCTS = require('../data/products')

class ProductService {
    constructor() {
        console.log('Product Service initalized')
    }
    //async api with Promise
    findAll() {
        return new Promise((resolve, reject) => {
            if (PRDOUCTS) {
                setTimeout(resolve, 5000, PRDOUCTS)
            } else {
                setTimeout(reject, 5000, { message: 'Products Not Found' })
            }
        })
    }
}
module.exports = new ProductService()


src/index.js
const productService = require('./services/product.service')

function main() {
    //call async service
    console.log('start')
    productService.findAll()
        .then(products => {
            console.log(products)
        })
        .catch(err => {
            console.log(err)
        })
    console.log('end')
}
main()

Using Promises: with async...await
....................................
src/index.js
const productService = require('./services/product.service')

async function main() {

    try {
        const products = await productService.findAll()
        console.log(products)
    }
    catch (err) {
        console.log(err)
    }

}
main()

Case Study:

CURD operations:

Create USER service, having users data like id,name,status (array of users)

1.return all users
2.return user by id
3.insert new user
4.update existing user
5.remove existing user

Note: js array apis for insert,delete,update,find
.....................................................................................
			ES 6 module pattern
.....................................................................................

CJS and es 6 modules are same , means to share code.

keywords

To share code

1.export  ===exports
2.export default = module.exports

To link/use code

3.import ===require function



src/util.js

//export 

export const name = 'Subramanian'
export const age = 44
export const status = true
export const address = {
    city: 'Coimbatore',
    state: 'TN'
}
export const getInfo = () => {
    return 'info'
}
export const skills = [
    'java', 'js', 'devops'
]
src/index.js
import { name, age, address, skills, status, info } from './util'


function main() {
    console.log(name)
    console.log(age)
    console.log(address)
    console.log(skills)
    console.log(status)
    console.log(info())

}
main()


G:\Marsh\nodejs\es6modules>node src/index.js
(node:19580) Warning: To load an ES module, set "type": "module" in the package.json or use the .mjs extension.
(Use `node --trace-warnings ...` to show where the warning was created)
G:\Marsh\nodejs\es6modules\src\index.js:1
import { name, age, address, skills, status, info } from './util'
^^^^^^

SyntaxError: Cannot use import statement outside a module
    at internalCompileFunction (node:internal/vm:77:18)
    at wrapSafe (node:internal/modules/cjs/loader:1288:20)
    at Module._compile (node:internal/modules/cjs/loader:1340:27)
    at Module._extensions..js (node:internal/modules/cjs/loader:1435:10)
    at Module.load (node:internal/modules/cjs/loader:1207:32)
    at Module._load (node:internal/modules/cjs/loader:1023:12)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:135:12)
    at node:internal/main/run_main_module:28:49

Node.js v20.11.1

Note:
 Node.js does not support keywords directly.

How to run es6 modules inside node?

1.create a file called package.json
G:\Marsh\nodejs\es6modules> npm init --yes
 

package.json
{
  "name": "es6modules",
  "version": "1.0.0",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}

2.file name must be renamed -  util.mjs

//export 

export const name = 'Subramanian'
export const age = 44
export const status = true
export const address = {
    city: 'Coimbatore',
    state: 'TN'
}
export const getInfo = () => {
    return 'info'
}
export const skills = [
    'java', 'js', 'devops'
]

4.while importing 
import { name, age, address, skills, status, getInfo } from './util.mjs'


function main() {
    console.log(name)
    console.log(age)
    console.log(address)
    console.log(skills)
    console.log(status)
    console.log(getInfo())

}
main()

................................

src/services/todoservices.mjs


// class TodoService {
//     constructor() {

//     }
//     //api 
//     findAll() {
//         return "todos"
//     }
// }
// export default TodoService;

export default class TodoService {
    constructor() {

    }
    //api 
    findAll() {
        return "todos"
    }
}

src/index.js
import TodoService from './services/todo.service.mjs'



function main() {
    let todoService = new TodoService()
    console.log(todoService.findAll())

}
main()

Rules:

1.in a single file , you cant have multiple "export default".
2.in a single file,you can have multiple export
3.in a single file, you can mix export and export default

eg:
src/services/todo.service.mjs

export const config = {
    message: "config"
}

export default class TodoService {
    constructor() {

    }
    //api 
    findAll() {
        return "todos"
    }
}

While import export default should go first,then export

import { name, age, address, skills, status, getInfo } from './util.mjs'

// import TodoService from './services/todo.service.mjs'
//export and export default together


import TodoService, { config } from './services/todo.service.mjs'


function main() {
    console.log(name)
    console.log(age)
    console.log(address)
    console.log(skills)
    console.log(status)
    console.log(getInfo())

    let todoService = new TodoService()
    console.log(todoService.findAll())

    console.log(config)

}
main()

.....................................................................................
			Types of modules
.....................................................................................

1.Custom module
  built by us
2.built in modules
   provided by node.js  
3.provided by third party/community
  libs,frameworks


Built in Node.js Modules:
.........................
https://nodejs.org/docs/latest/api/

Built in node modules provides

1.non blocking networking io apis
   -tcp,http,datagram etc...
2.timers
3.file system api
   to read and write data into disk files
4.common apis
   os,events


Common apis:

1.OS
const os = require('node:os')

function main(){
    console.log(os.arch())
    console.log(os.cpus())
}
main()

./ vs ''
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('node:os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?

require('node:os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_modules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.


.....................................................................................
				  Events

Node.js is event driven arch, some program emits events called emitter and some program lisents for those events called "listeners".

Using events module we can build event programming model.

As of now , we are going to discuss simple events with in objects, later in microservices we will see the distributed event driven arch.

Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.

For instance: a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is opened; a stream emits an event whenever data is available to be read.		


//how events are emitted and how to listen for events
//this is not io events , just custom events
//io events will see later.

const EventEmitter = require('node:events')

class Sales extends EventEmitter {
    constructor() {
        super()
        //register listener
        this.on('sold', (evt) => {
            console.log(evt)
        })
    }
    //biz
    sale(product) {
        //fire /emit event
        this.emit('sold', product)
    }
}


function main() {
    let sales = new Sales()
    sales.sale({ id: 1, name: 'Phone' })
}
main()
....................................................................................
			 IO modules

1.File system IO
2.HTTP IO - Web Programming

...................................................................................
			   IO Modules
...................................................................................

1.file system io
   file system io , how to read data from disk file
2.network io


File System IO:
=>We can read and write files from the disk in  two ways
  1.blocking way
  2.nonblocking way
=>We can read and write files using two mode (nonblocking apis)
  1.NonStreaming mode
  2.Streaming mode

=>All file operations are handled by
  "Worker Threads" from Worker Thread Pool - either it is blocking or non blocking    io.
=>Files are handled using callback style or promise style.
=>Files operations are handled by "fs" module

How to read File using nonblocking pattern? using callbacks

fs.readFile(path[, options], callback)

path <string> | <Buffer> | <URL> | <integer> filename or file descriptor
options <Object> | <string>
 encoding <string> | <null> Default: null
 flag <string> See support of file system flags. Default: 'r'.
 signal <AbortSignal> allows aborting an in-progress readFile

callback <Function>
  err <Error> | <AggregateError>
  data <string> | <Buffer>
.....................................................................................

eg:
Use Case : read file using callbacks

const fs = require('node:fs');

const fs = require('node:fs');

//read

function readFile() {
    const filePath = './src/assets/info.txt'
    const options = {
        encoding: 'UTF-8'
    }
    fs.readFile(filePath, options, (err, data) => {
        if (err) throw err
        console.log(data)
    })

}

function main() {
    console.log('start')
    readFile()
    console.log('end')
}
main()

Task:
 The above code is based on callback, convert this into promise.
 Note: You have to write your own promise Implementation



const fs = require('node:fs/promises');


async function readFile() {
    const filePath = './src/assets/info.txt'
    const options = {
        encoding: 'UTF-8'
    }
    // fs.readFile(filePath, options, (err, data) => {
    //     if (err) throw err
    //     console.log(data)
    // })
    try {
        const data = await fs.readFile(filePath, options)
        console.log(data)
    }
    catch (err) {
        console.log(err)
    }

}

function main() {
    readFile()
}
main()
.....................................................................................
.....................................................................................		How to read File using blocking pattern?
....................................................................................

const fs=require('node:fs')

async function main() {
    const filePath = './src/assets/info.txt'
    const options = {
        encoding: 'UTF-8'
    }
    console.log('start')
    const data = fs.readFileSync(filePath, options)
    console.log(data)
    console.log('end')
}
main()
.....................................................................................
			Mode of fs read and write
.....................................................................................

1.Non Streaming Mode

2.Streaming  Mode

1.Non Streaming Mode

  only file io is supported, network io not supported

 -once file is read, the entire file is loaded into node process buffer(memory), then it will be delivered to caller.

-if more files are loaded into node process, node process gets crashed.

-non streaming mode is not suitable for large and big files read or write operation.

fs.readFile() and fs.writeFile are non streaming apis


2.Streaming apis:
   supported by fs and also network apis


-Streaming is nothing but flow of data(chunks).
-Streaming allows move the data from one place to another place one by one.
-Streaming apis are other wise called evented io. which is powered events.



Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + write

Node has lot of built in stream apis
....................................

Built in readable Streams:

-HTTP responses, on the client
-HTTP requests, on the server
-fs read streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdout and stderr
-process.stdin

Writable Streams:

-HTTP requests, on the client
-HTTP responses, on the server
-fs write streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdin
-process.stdout, process.stderr

All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

Common events in all io
.........................


1.data event:
 which is emitted by node, for each chunk.

2.close event:
  The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

3.end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

4.Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.

const fs = require('node:fs');

//read

function readFile() {
    const filePath = './src/assets/info.txt'
    const options = {
        encoding: 'UTF-8'
    }
    const inputStream = fs.createReadStream(filePath, options)

    //read data
    //attach events
    let data = ''
    inputStream.on('data', (chunk) => {
        data += chunk
    })
    inputStream.on('end', () => {
        console.log(data)
    })
    inputStream.on('close', () => {
        console.log('close event is called')
    })
    inputStream.on('error', (err) => {
	consoe.log(err)
        console.log('error event is called')
    })
}

function main() {
    readFile()
}
main()
....................................................................
Writing file using Stream:
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');

const config = {
    encoding: 'utf8',
    flag: 'w'
};
const outputStream = fs.createWriteStream(fileName, config);

const grains = ['wheat', 'rice', 'oats'];

grains.forEach(grain => {
    outputStream.write(grain + " ");
    console.log("Wrote: %s", grain);
});

outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
})
................

.....................................................................................
				Back Pressure
....................................................................................

When input stream and output stream works together.

Backpressure:
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


How to handle back pressure?

 apis  : pause,resume,drain event

pause : to close the upstream, not to emit data
resume : to open the open upstream , to emit data

drain event: if drain event is called, means buffer is empty

In order test back pressure , we need atleast 1gb file.



Create big file code:
//big file creation
const fs = require('fs');
const path = require('path')

const filePath = path.join(__dirname, "assets/big.file")

const file = fs.createWriteStream(filePath);

for (let i = 0; i <= 1e6; i++) {
    file.write('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n');
}

file.end();

..

const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    let buffer_good = writeStr.write(chunk);
    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});
readerStream.on('end', function () {
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});

....................................................................................
			 Using Pipe
...................................................................................
const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputFileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
.....................................................................................
			HTTP programming
....................................................................................
Node was created to build non blocking web server and web applications.
Node provides single event loop thread which handles lot of concurrent http requests.
Node offers high level http wrapper apis to talk to os apis.
Node offers http as object.

HTTP Objects

1.Agent -  http.Agent
  For handling connections between and server

2.ClientRequest - http.clientRequest
  For creating http clients

3.Server - http.Server
  For creating web servers,we can create app and deploy on top of server.
  
4.ServerResponse - http.ServerResponse
  ServerResponse is outputstream of "http socket"

5.IncomingMessage -http.IncomingMessage
    The payload which is sent by client -  Message

6.OutgoingMessage -http.OutgoingMessage
    The data which is sent by server - Message

7.Global Methods of http
  
 1.createServer
    factory method to create http server instance.

HTTP events:
 
 There are three types of events

1.HTTP Request events
  Which are triggered whenever client request is recived by server

request.on('nameoftheevent',listner)

2.Http Response events
   Which are triggered whenever server response is sent by server

response.on('nameoftheevent',listner)

3.Server Events
   Server events are triggered during server startup,connection,handshake,request

 server.on('nameoftheevent',listner)

common events:
data,close,end,error

Note:
 Each Object has its own events apart from common events.

////////////////////////////////////////////////////////////////////

First Web Server: Helloworld
//simple web server
const http = require('node:http')

//create Http Server
const server = http.createServer((request, response) => {
    //write code to handle request and response
    response.write('Hello')
    //close the stream
    response.end()
})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

How to attach Events?
request,response,server.

//simple web server
const http = require('node:http')

//create Http Server
const server = http.createServer((request, response) => {
    //write code to handle request and response
    response.write('Hello')
    //close the stream
    response.end()
})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

//attach server listener
server.on('request', (request, response) => {
    console.log(`Request received on ${new Date()} URL ${request.url} method ${request.method}`)
})

...................................................................................
			  How to send json payload 
.....................................................................................
//simple web server
const http = require('node:http')
const USERS = require('./data/users')

//create Http Server
const server = http.createServer((request, response) => {
    //send as json
    const usersJson = JSON.stringify(USERS)

    //send status code and content type
    response.writeHead(200, {
        'Content-Type': 'application/json'
    })

    response.write(usersJson)
    //close the stream
    response.end()
})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

//attach server listener
server.on('request', (request, response) => {
    console.log(`Request received on ${new Date()} URL ${request.url} method ${request.method}`)
})
.....................................................................................
			Modularization,async api, web
.....................................................................................

src/services/user.service.js
const USERS = require('../data/users')

class UserService {

    findAll() {
        return new Promise((resolve, reject) => {
            //send users after 1000 ms
            const usersJson = JSON.stringify(USERS)
            setTimeout(resolve, 5000, usersJson)
        })
    }

}
module.exports = new UserService()

src/index.js
//simple web server
const http = require('node:http')
const userService = require('./services/user.service')

//create Http Server
const server = http.createServer(async (request, response) => {

    try {
        const usersJson = await userService.findAll()
        //send status code and content type
        response.writeHead(200, {
            'Content-Type': 'application/json'
        })
        response.write(usersJson)
        //close the stream
        response.end()
    }
    catch (err) {
        response.writeHead(500, {
            'Content-Type': 'application/json'
        })
        response.write({ err: err })
        response.end()
    }

})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

//attach server listener
server.on('request', (request, response) => {
    console.log(`Request received on ${new Date()} URL ${request.url} method ${request.method}`)
})
....................................................................................
			How to get Input from User
....................................................................................

src/services/user.service.js
const USERS = require('../data/users')

class UserService {
    save(user) {
        // Todo: later you can insert this into db
        console.log(user)
    }

}
module.exports = new UserService()


const http = require('node:http')
const userService = require('./services/user.service')

//create Http Server
const server = http.createServer((request, response) => {
    //read data from client.
    let data = ''
    request.on('data', (chunk) => {
        data += chunk
    })
    request.on('end', () => {
        userService.save(data)
        response.end('saved')
    })

})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

//attach server listener
server.on('request', (request, response) => {
    console.log(`Request received on ${new Date()} URL ${request.url} method ${request.method}`)
})

.....................................................................................
		   Building RestFull web services
.....................................................................................

1.Resources
   Customer,Product,Item,Payment
2.API
   findAll,findBYId,update,Remove,filter

3.URL 
   Resources and apis must be indentified by URL

4.APIs are mapped against HTTP verbs
  Read - GET
  Save  -POST
  update - PUT
  remove -  DELETE


Each Resource is identified by unique url

  /api/customer
  /api/products

Each Resource has collection of apis and which mapped against HTTP verbs

 findAll - GET


Having core node.js http module we cant build production ready webservices with minimum code, we need to write plenty of boiler plate code.

Node.js team in the begining started working on an abstraction called "framework"
			   "Express.js"
...................................................................................
...................................................................................
				NPM
.....................................................................................

What is npm?
 npm is the world's largest software registry.
 open source developers from every part of the world use npm to share and borrow packages.
 many organizations use npm to manage private development as well.

In js, you might have created lib/framework/utility, if you want to share to other developers in the world or within your organization or your team - npm helps.


NPM consists of three components

1.the website - used to discover packages, setup profiles and manage other aspects of npm -https://www.npmjs.com/

2.CLI runs from the terminal, and how most developers interact with npm.
  npm is cli name/command , which is distributed alone node.js itself

3.registry - it is  large public database of js software and the meta information surrounding it.

core concepts in npm:

1.package
2.module

What is package?
   A package is a "file or directory" that is described by a "package.json" file

   A package must contain package.json file in order to be published to the npm    registry


Modules:
  A module is any "file or directory" in the "node_modules" directory that can be loaded by the node.js require function.

 A javascript file
....
....................................................................................
				How to create npm package
....................................................................................

package.json

=>It is file which describes about your project/app/file/directory.

i have created a project like

myapp/src/util/lib.js

class A{}

module.exports = new A()

myapp/src/util/index.js
const A= require('./util/lib.js')

Can you call this project as "package"

No
Because this project does not contain "package.json",Which are called module
...................................................................................

i have created a project like

myapp/src/util/lib.js

class A{}

module.exports = new A()

myapp/src/util/index.js
const A= require('./util/lib.js')

myapp/package.json


Can you call this project as "package"

Yes

Why
Can you call this project as "package"

No

Why package.json?

=>if package.json is there, only we can transfer/share to other developers via "npm registry"

Note:
 Every js project must have package.json file

Steps:

1.create folder
>mkdir mynpm-apps
>cd mynpm-apps
>mkdir src

2.create package.json

Before create you have to ensure that npm has been installed.

npm init <initalizer>

npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

package.json

{
  "name": "mynpmapps",
  "version": "1.0.0",
  "description": "This is demo package",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "my",
    "demo",
    "package"
  ],
  "author": "Subramanian Murugan",
  "license": "ISC"
}
name:
 This is used to publish package into registry

version:
   if you publish package into registry, which is differentiated by "version"

"1.0.0" - version no is based on the concept called "SEM Ver" concept- Semantic versioning.
 Major.minor.patch

main:
  It is main file used /entry file in the package , generally it would index.js or main.js

description:
  It explains the nature of packages- what is this packge.

Keywords:
  Used to discover your packages using npm search command

author:
  Who is author of this package

license:
  You should specify a license for your package so that people know how they are permitted to use it.
		.................................................................................
			   node_modules
.................................................................................

  it is folder , used to install any node packages, the node program always looks up the packages from the current folder.

....................................................................................
				Node Packages

How to install node packages which was distributed by others?

npm install [<package-name>]
npm i [<package-name>]

npm i [<package-name>] --options


Options:

 --save
     for production + dev
 --save-dev
     -for only for dev 
 --production
    -for only production
  -g
    -for tool purpose -dev

No options are given by default "--save"

if you want to use any lib

Steps;
1.ensure that package.json is created or not - one time
2.npm i packageName --options
3.after installing you can verify , the node_modules folder is created and installed
  libs inside that folder.
  You have to verify package.json aswell, there is one entry is added

  "dependencies": {
    "lodash": "^4.17.21"
  }


3.How to use package inside our code?
  Using cjs or es6 module.

//i want to use lodash lib
const _ = require('lodash')

//start using lib

function main() {
    const res = _.partition([1, 2, 3, 4], n => n % 2);
    console.log(res)
}
main()

Application mode

1.dev
2.test
3.prod

dev : any dependency required for development only
  --save-dev
test : 
   any dependency required for development only - test
   --save-dev
prod:
  dependency used in dev and production... 
  --save
"dependencies": {
    "lodash": "^4.17.21"
  }

..................................................................................
			 Test /Dev Only Dependency
.................................................................................

Libs required for dev and test

tools
   -compilers,webservers
   -testing libs and framworks 

eg:
  mocha - test runner is used for running test case
  chai.js -test assertion lib used for writing test cases
  jest -  test runner is used for running test cases

how to install chai?

G:\Marsh\nodejs\mynpm-apps>npm i chai --save-dev

added 7 packages, and audited 9 packages in 2s

found 0 vulnerabilities

 "devDependencies": {
    "chai": "^5.1.1",
    "mocha": "^10.7.3"
  }
.....................................................................................
			How to prepare your app for production
.....................................................................................

When you upload the app into source code repository like "github/bitbucket" , we never upload node_fodler.

Steps for Testing:

1.just delete node_modules folder

2.open command prompt

3.create production app

npm install --production
  it scans package.json which install only from  production dependencies
or
npm install --omit=dev
  it scans package.json which install only from  production dependencies			
....................................................................................
		How to install all dependencies 
....................................................................................
G:\Marsh\nodejs\mynpm-apps>npm i
.........................................................................................................................................................................
			How to remove /uninstall package

npm uninstall mocha --save-dev
 "devDependencies": {
    "chai": "^5.1.1"
  }
,,,,,,,,,,,,,........................................................................
			  Global Packages
....................................................................................
Global package is installed not inside project, installed globally.
Global packages are generally tools to create projects,webservers,test runtime like so.

nodemon:
  nodemon is a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected.
 
npm install nodemon -g

global modules are available like executable files

How to test?

G:\Marsh\nodejs\mynpm-apps>nodemon --help
  Usage: nodemon [options] [script.js] [args]

  Options:

  --config file ............ alternate nodemon.json config file to use
  -e, --ext ................ extensions to look for, ie. js,pug,hbs.
  -x, --exec app ........... execute script with "app", ie. -x "python -v".
  -w, --watch path ......... watch directory "path" or files. use once for
                             each directory or file to watch.



G:\Marsh\nodejs\mynpm-apps>nodemon src/index.js
[nodemon] 3.1.4
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,cjs,json
[nodemon] starting `node src/index.js`
server is ready

You just change any file content, see the output without restarting.

....................................................................................
			 scripts
....................................................................................
 if you want to automat the js app workflows, scripts section is used.

scripts has ,script command and task to be executed.

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },

test - is command
"echo \"Error: no test specified\" && exit 1" - task to be executed

in npm we have many built in commands.
eg
 start
 stop
 publish
 test
 pack
 postinstall
 preinstall
etc..
https://docs.npmjs.com/cli/v8/using-npm/scripts#npm-rebuild

Use case :
 We can run node apps using scripts
 we can run webservers using scripts
 we can initalize the test env using scripts
 we can start containers using scripts
 etc...

how to execute scripts commands?

npm commandName
eg
npm start
npm test
npm pack
etc..

eg:
G:\Marsh\nodejs\mynpm-apps>npm test

> mynpm-apps@1.0.0 test
> echo "Error: no test specified" && exit 1

"Error: no test specified"


Can we run our node app via script?

Yes

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node src/index.js"
  },
G:\Marsh\nodejs\mynpm-apps>npm start

> mynpm-apps@1.0.0 start
> node src/index.js

server is ready
.............................................................................
			Custom Script command
...............................................................................

You can give any name

eg:
  "scripts": {
     "subu": "node src/index.js"
  }

How to run this command ?

G:\Marsh\nodejs\mynpm-apps>npm subu
Unknown command: "subu"


Did you mean this?
  npm run subu # run the "subu" package script
To see a list of supported npm commands, run:
  npm help

YOu cant run custom command using "npm commandName"

Then how to run?

npm run commandName

G:\Marsh\nodejs\mynpm-apps>npm run subu

> mynpm-apps@1.0.0 subu
> node src/index.js

server is ready


			Global Modules and scripts
.....................................................................................

Tools we have installed globally like nodemon.

In order to avoid version mismatch, we can install any tools(webservers,compilers,utilites) as local module.

G:\Marsh\nodejs\mynpm-apps>npm uninstall nodemon -g

removed 29 packages in 1s

G:\Marsh\nodejs\mynpm-apps>nodemon
'nodemon' is not recognized as an internal or external command,
operable program or batch file.


npm install nodemon -save-dev
After installing,nodemon is not available to execute like 

nodemon src/index.js
Error:
nodemon' is not recognized as an internal or external command,
operable program or batch file.

Solution:
 We have to configure inside scripts section using builtin commoand or custom command

"scripts": {
      "dev": "nodemon src/index.js"
  }

npm run dev
.....................................................................................
			How to use tools without even installing locally
.....................................................................................
Can i use tools like webserver,compiler,code generator without even installing inside project as dev?

npx command

Either local or global module we need to install, it occupies some amount memory.
if you want to execute tools with latest version always,you have to upgrade, instead of upgrading , we can directly execute the latest version of binary.

npx
.....................................................................................

Alternate to npm

1.npx
2.yarn
3.npmn
.....................................................................................
....................................................................................
			  Express.js - Web /Api Framework For node.js
.....................................................................................


What is express?
Express Fast, unopinionated, minimalist web framework for Node.js
express is built on top of http core module.


What apps can be built using express?


1.RESTFull WebServices

2.Dynamic content generation apps -  spring mvc, .netmvc.   with ui


Core features of Express:

1.Abstraction on core http module
2.lot of apis to send data like json api
3.routers : to create HTTP based web services and apps quickly.
4.middlewares : to extend core framework like - logging,database,security,templates...

Types of distributed Apps:

1.Monolithic App
2.Microservices

Express can be used to build Microservices?

 No,
Express is just monolithic App framework
.....................................................................................
		Express Key concepts: in express every thing object

Objects in express

1.Application
  We call Container object which containe other objects
  entry and exit of an application
  application is created by calling function

2.Request

3.Response

4.Router


1.Application object roll:

-Routing HTTP requests
-Configuring middleware
-Rendering HTML views
-Registering a template engine

Express Project setup:

1.You can install express dependencies in existing plain node project

2.You can use express cli , to create project structures

Steps:

1.create project folder
2.create src folder
3.npm init
4.install express dependency
5.start writing code

mkdir express-app
cd express-app
npm init
...........................

Installing express framework:
.............................

npm i express --save
npm i nodemon --save-dev

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon src/app.js"
  },
.....................................................................................
				Express- Coding
.....................................................................................

Express : HelloWorld

File Name : app.js - conventional name but you can save index.js as well.

//import express function
const express = require('express')
// console.log(express)

//creating application object
const app = express()

// console.log(app)

//api:
app.get('/hello', (req, res) => {
    //send response
    res.end('Hello Express')
})


//start the server

app.listen(3000, () => {
    console.log('Express Server is Ready!')
})
.................................................................................
			HTTP verbs and CURD
....................................................................................

HTTP Verbs         Operation Type

GET                Read

POST               Write

PUT                Update

DELETE             Remove

URL Pattern:
///////////
Every Http Verbs are mapped against url

/api/customers        -GET ,POST,PUT,DELETE
/api/products
/api/reviews
 
CURD:
const express = require('express')
const app = express()

app.get('/api/customers', (req, res) => {
    res.end('customers -get')
})
app.post('/api/customers', (req, res) => {
    res.end('customers -post')
})
app.put('/api/customers', (req, res) => {
    res.end('customers -put')
})
app.delete('/api/customers', (req, res) => {
    res.end('customers -delete')
})
app.listen(3000, () => {
    console.log('Express Server is Ready!')
})
...................................................................................
			PORT,getting Server Info
...................................................................................

const express = require('express')
const app = express()

const PORT = 3000

app.get('/api/customers', (req, res) => {
    res.end('customers -get')
})
app.post('/api/customers', (req, res) => {
    res.end('customers -post')
})
app.put('/api/customers', (req, res) => {
    res.end('customers -put')
})
app.delete('/api/customers', (req, res) => {
    res.end('customers -delete')
})
const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
.....................................................................................
			Modularity,Async,JSON Payload
....................................................................................

src/services/customer.service.js

const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
}
module.exports = new CustomerService()

src/app.js
const express = require('express')
const app = express()
const customerServicce = require('./services/customer.service')

const PORT = 3000

app.get('/api/customers', async (req, res) => {
    try {
        const customers = await customerServicce.findAll()
        res.status(200).json(customers)
    }
    catch (err) {
        res.status(500).json(err)
    }
})
const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})

...................................................................................
			Externalized configuration
...................................................................................

We are going to use ".env" file.


We are going to use ".env" file.

Step : 1 Create file under root project dir
project
 |
 .env

Step 2: install dotenv dependency

npm install dotenv --save

Step 3: grab env variables
const express = require('express')
const { findAll } = require('./services/user.service')
require('dotenv').config()

const app = express()

//console.log(process.env.PORT)

const PORT = process.env.PORT || 3000

app.get('/', (req, res) => {
    res.end('Home Page')
})
app.get('/api/users', async (req, res) => {
    try {
        const users = await findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

TasK
.....
Multi Enviroment configuration: explore how to configure for different environments
like production,dev,staging,testing
https://www.npmjs.com/package/dotenv
...................................................................................
....................................................................................
			Resources
....................................................................................

YourApp
  |
  routers - controllers
    |
    products
    customers
    payments
 |
  services
    products
    customers
    payments
 |
  repository
    products
    customers
 |
  
 app.js
..................................................................................... Router:
  It is object used to isloate apis into separate folders and files


eg:

src/services/customer.service.js

const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
    async save() {
        return "save"
    }
}
module.exports = new CustomerService()

src/services/product.service.js

const PRODUCTS = [{
    id: 1,
    name: 'phone'
}]

class ProductService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, PRODUCTS)
        })
    }
    async save() {
        return "save"
    }
}
module.exports = new ProductService()
...............

Router:

src/routers/product.router.js
const express = require('express')
const productService = require('../services/product.service')
//create Router Object
const productRouter = express.Router()

productRouter.get('/', async (req, res) => {
    try {
        const products = await productService.findAll();
        res.json(products)
    }
    catch (err) {
        res.json({ err: err })
    }
})

productRouter.post('/', async (req, res) => {
    try {
        const product = await productService.save();
        res.json({ product })
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = productRouter

src/routers/customer.router.js
const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter

src/app.js
const express = require('express')
// const customerRouter = require('./routers/customer.router')
require('dotenv').config()
const app = express()

//Configure the router with application object
// app.use('/api/customers', customerRouter)
app.use('/api/customers', require('./routers/customer.router'))
app.use('/api/products', require('./routers/products.router'))

const PORT = process.env.PORT || 3000


const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
.....................................................................................
			  Dynamic Parameters
.....................................................................................

eg:

 GET /api/customers/1 
 GET /api/customers/2 

How to read paramter

router | app.get('/:id',(req,res)=>{
  const id = req.params.id
})

eg:


const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
    findById(id) {
        return CUSTOMERS.find(customer => customer.id === id)
    }
    async save() {
        return "save"
    }
}
module.exports = new CustomerService()


Router:
const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const customer = await customerServicce.findById(id);
        if (customer) {
            return res.json(customer)
        }
        return res.status(500).json({ err: `Requestd Customer ${id} Not Found` })

    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter

Testing:
GET localhost:3000/api/customers/1

{
    "id": 1,
    "name": "Subramanian",
    "location": "Coimbatore"
}

GET localhost:3000/api/customers/2

{
    "err": "Requestd Customer 2 Not Found"
}
....................................................................................
			Payload
...................................................................................

Service
const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
    async findById(id) {
        return CUSTOMERS.find(customer => customer.id === id)
    }
    async save(customer) {
        return CUSTOMERS.concat(customer)
    }
}
module.exports = new CustomerService()




Router
const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const customer = await customerServicce.findById(id);
        if (customer) {
            return res.json(customer)
        }
        return res.status(500).json({ err: `Requestd Customer ${id} Not Found` })

    }
    catch (err) {
        res.json({ err: err })
    }
})
customerRouter.post('/', (req, res) => {
    try {
        let customer = ''
        req.on('data', (chunk) => {
            customer += chunk
        })
        req.on('end', async () => {
            const customerObj = JSON.parse(customer)
            const users = await customerServicce.save(customerObj)
            return res.status(201).json(users)
        })
    }
    catch (err) {
        res.json({ err: err })
    }
})


customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter
...................................................................................
				Express middlewares
...................................................................................

Middlewares:

 What is Middleware?
 
 Middleware is javascript function that have access request object and response and next function in the application request response cycle.
  
 The difference between normal function which handles req and response with express , express takes thrird arg

 normal function
  app.get('url',(req,res)=>{})

 Middleware function
  app.get('url',(req,res,next)=>{

  })
 req and res are objects
 next is a function

The next function is a function in the express router which,when invoked,executes the middleware succeeding the current middleware.

Tasks are middleware is doing:

1.Execute any code
2.Make changes to request and response object before handling real req and res cycle.
3.Middlwares can be attached on application object and also router object


use Method
  use method is used to registry middleware.

app.use
router.use

app.use('/api/users', require('./routers/users/user.router'))
 In this code we have registred already middleware which is called as "routerMidleware" - Router itself is middleware.

How to our own middleware? - Custom Middleware.

Use Case : Middleware for GET /hello

const express = require('express')
require('dotenv').config()

const app = express()
const PORT = process.env.PORT || 3000

//middleware 
//req is object
//res is object
//next is function
app.get('/hello', (req, res, next) => {
    //middleware logic
    console.log('middleware is called')
    //move to next middleware in the chain or to request handler
    next()
})
app.get('/hello', (req, res) => {
    return res.end('hello')
})


const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
//////////////////////////////////////////////////////////////////////////////////
		Global Middleware : any url any method
...................................................................................
const express = require('express')
require('dotenv').config()

const app = express()
const PORT = process.env.PORT || 3000

//middleware 

app.use((req, res, next) => {
    //middleware logic
    console.log('global middleware middleware is called')
    //move to next middleware in the chain or to request handler
    next()
})

//req is object
//res is object
//next is function
app.get('/hello', (req, res, next) => {
    //middleware logic
    console.log('hello middleware is called')
    //move to next middleware in the chain or to request handler
    next()
})
app.get('/hello', (req, res) => {
    return res.end('hello')
})
app.get('/hai', (req, res) => {
    return res.end('hai')
})
app.get('/greeter', (req, res) => {
    return res.end('greeter')
})
const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
....................................................................................
		Specific Url , any http method
....................................................................................

const express = require('express')
require('dotenv').config()

const app = express()
const PORT = process.env.PORT || 3000

//middleware 

app.use((req, res, next) => {
    //middleware logic
    console.log('global middleware middleware is called')
    //move to next middleware in the chain or to request handler
    next()
})

app.use('/hai', (req, res, next) => {
    console.log(`Hai middleware, Method is ${req.method}`)
    next()
})
app.get('/hello', (req, res) => {
    return res.end('hello')
})
app.get('/hai', (req, res) => {
    return res.end('hai')
})
app.post('/hai', (req, res) => {
    return res.end('hai')
})
app.put('/hai', (req, res) => {
    return res.end('hai')
})
app.delete('/hai', (req, res) => {
    return res.end('hai')
})

const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
....................................................................................
			Router level middleware
....................................................................................

Middleware is set on Router Object

router.use((req,res,next)=>{
  next()
})
router.use('/url'(req,res,next)=>{
  next()
})
router.get('/url'(req,res,next)=>{
  next()
})

const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

customerRouter.use((req, res, next) => {
    console.log('customerRouter is called')
    next()
})

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const customer = await customerServicce.findById(id);
        if (customer) {
            return res.json(customer)
        }
        return res.status(500).json({ err: `Requestd Customer ${id} Not Found` })

    }
    catch (err) {
        res.json({ err: err })
    }
})
customerRouter.post('/', (req, res) => {
    try {
        let customer = ''
        req.on('data', (chunk) => {
            customer += chunk
        })
        req.on('end', async () => {
            const customerObj = JSON.parse(customer)
            const users = await customerServicce.save(customerObj)
            return res.status(201).json(users)
        })
    }
    catch (err) {
        res.json({ err: err })
    }
})


customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter
.....................................................................................
.....................................................................................
		  Can we pass parameters to the Middleware so that we can 
		     configure middleware - Configurable Middlewares
....................................................................................
Middleware which takes parameter , it should be higher order function. - function should return another function.

inner function is middleware.

Syntax: without explicit parameter

app.use(function(req,res,next)=>{})

Syntax: with explicit paramter

const mymiddleware = function(param) {

  return function(req,res,next){
     //access param

    next()
  }
}
app.use(mymiddleware('param'))


eg:

const myMiddleware = function (param) {
    //return function
    return function (req, res, next) {
        console.log('Got Param', param)
        next()
    }
}

app.use(myMiddleware('Marsh'))
.....................................................................................
.....................................................................................
				Types of Middlewares
.....................................................................................
1.Application middleware
2.Router level middlware
3.Error handling middleware
4.Third party middleware

1.Application middleware:
  Middleware is attached on application object

2.Router level middlware

->writing router:

 In express except ,request and response , all features including router is middleware.
 Router is in built middleware.

src/app.js
const express = require('express')
const customerRouter = require('./router/customer.router')
const app = express();

//register middleware 
app.use('/api/customers', customerRouter)

//api - based on resources - customer,products,payments


app.listen(3000, () => {
    console.log('Express server is running')
})

src/app/router/customer.router.js
const express = require('express')
const customerRouter = express.Router()

//middleware
customerRouter.use(function (req, res, next) {
    console.log('customer global middleware')
    next()
})
customerRouter.get('/', function (req, res, next) {
    console.log('customer get middleware')
    res.set({
        'customer': 'CUSTOMER GET'
    })
    next()
})

//api 
customerRouter.get('/', (req, res) => {
    res.json({ message: 'CUSTOMERS' })
})
customerRouter.post('/', (req, res) => {
    res.json({ message: 'customers post' })
})

module.exports = customerRouter

.....................................................................................
				Error Handling middleware
.....................................................................................

To handle error we have error handling middleware.


Error handling middleware takes four args instead of three arg.

app.use((err, req, res, next)=> {
    //handle error 
     console.err(err.message)
    //send error report to the user
    res.status(500).send('something went wrong')
})


const express = require('express')
const app = express();

app.use((err, req, res, next) => {
    //  next()
    res.status(500);
    res.send('Internal Server Error');
})

//api test error 
app.get('/api/greet/:message', (req, res) => {
    const message = req.params.message
    if (message === 'hello') {
        res.send(message)
    } else {
        throw new Error('Broken...')
    }
})

app.listen(3000, () => {
    console.log('Express server is running')
})
.....................................................................................
...................................................................................
			Built in and third party middlewares
...................................................................................
Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.
https://expressjs.com/en/resources/middleware.html

in order to parse the incoming payload into javascript object.

Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.


in order to parse the incoming payload into javascript object.

body-parser:

Node.js body parsing middleware.

Parse incoming request bodies in a middleware before your handlers, available under the req.body property.

Steps

1.install middleware
 npm install body-parser

2.require in the code
 const bodyParser = require('body-parser')

app.js
require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')

const PORT = process.env.PORT || 3000

//register bodyparserMiddleware
app.use(bodyParser.json())


app.use('/api/users', require('./routers/users/user.router'))


app.get('/', (req, res) => {
    res.end('Home Page')
})


//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

router/user.js
const express = require('express')
const { findAll, findById, save } = require('../../services/user.service')

//create Router
const UserRouter = express.Router()

//UserRouter middleware
UserRouter.use((req, res, next) => {
    console.log("User Router Globale Middleware")
    next()
})
UserRouter.post('/', (req, res, next) => {
    console.log("User Router Post Middleware")
    next()
})
//api
UserRouter.get('/', async (req, res) => {
    try {
        const users = await findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

UserRouter.get('/:id', async (req, res) => {
    const id = parseInt(req.params.id)
    try {
        const user = await findById(id);
        if (!user) {
            return res.json({ messgae: 'User Not Found' })
        }
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})

//here code receives input as plain string, not json standard string
// UserRouter.post('/', async (req, res) => {
//     try {
//         let data = ''
//         req.on('data', (chunk) => {
//             data += chunk
//         })
//         req.on('end', async () => {
//             const user = await save(data);
//             res.json(user)
//         })
//     }
//     catch (err) {
//         res.json({ err: err })
//     }
// })

UserRouter.post('/', async (req, res) => {
    try {
        const user = req.body
        console.log(user)
        const response = await save(user);
        res.json(response)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = UserRouter;
.....................................................................................
.....................................................................................
			  Logging Middlewars
....................................................................................

HTTP request logger middleware for node.js

Steps:
1.npm install morgan


require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const fs = require('fs')
const morgan = require('morgan')
const path = require('path')

const PORT = process.env.PORT || 3000

const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })

//register bodyparserMiddleware
app.use(bodyParser.json())
// app.use(morgan(':method :url :status :res[content-length] - :response-time ms'))
app.use(morgan('combined', { stream: accessLogStream }))

// app.use(express.json())

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

app.use('/api/users', require('./routers/users/user.router'))


app.get('/', (req, res) => {
    res.end('Home Page')
})


//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

...................................................................................
			CORS - Cross Origin Resource sharing
....................................................................................

What is CORS?
 Internet browsers usually block access to unindefined websites from your services and apis.
 Implementing this module enable your server to share its resources solely with clients who reside in the same domain as yours.

 CORS an HTTP header based mechanism implemented by browsers, enables a server or api to specificy any origins

Implementation:
Step 1:
npm install cors

Step 2:
activate cors in app.js via middleware

const cors = require('cors')

app.use(cors()) - enabled for all routes

Enabled for particular route:

app.get('/products/:id', cors(), function (req, res, next) {
  res.json({msg: 'This is CORS-enabled for a Single Route'})
})

Note:
 HTTP methods,get,post,delete,update syntax
 
  app.get('url',requestlistener)

  app.get('url',middleware,requestlistener)
 
Default CORS Configuration values:
{
  "origin": "*",
  "methods": "GET,HEAD,PUT,PATCH,POST,DELETE",
  "preflightContinue": false,
  "optionsSuccessStatus": 204
}

Eg:
 In the options, you have to list out what are the urls,methods, are allowed

require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const fs = require('fs')
const morgan = require('morgan')
const path = require('path')
const cors = require('cors')

const corsOptions = {
    origin: 'http://www.abce.com'
}

const PORT = process.env.PORT || 3000

const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })

//enabled default cors
app.use(cors(corsOptions))

// app.use(cors())

app.use(bodyParser.json())
app.use(morgan('combined', { stream: accessLogStream }))

app.use(bodyParser.urlencoded({ extended: false }))

app.use('/api/users', require('./routers/users/user.router'))


app.get('/', (req, res) => {
    res.end('Home Page')
})


//cors api
// app.get('/api/customers/:id',(req, res, next) => {
//     res.json({ msg: 'cors enabled for only this particular' })
// })

app.get('/api/customers/:id', (req, res, next) => {
    res.json({ msg: 'cors enabled for only this particular' })
})

//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})


Testing:
create index.html
  run this file in vs code with "live server"

How to install live server?
  live server is extensions that should be installed first.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        async function getCustomer() {
            const res = await fetch('http://localhost:3001/api/customers/1')
            const result = await res.json()
            console.log(result)
        }
        getCustomer()
    </script>
</body>

</html>

right click on this file and try to run , from there you can send request.


In the browser console.
content_script_bundle.js:1 Attempting initialization Mon Jul 15 2024 20:48:41 GMT+0530 (India Standard Time)
index.html:1 Access to fetch at 'http://localhost:3001/api/customers/1' from origin 'http://127.0.0.1:5500' has been blocked by CORS policy: The 'Access-Control-Allow-Origin' header has a value 'http://www.abce.com' that is not equal to the supplied origin. Have the server send the header with a valid value, or, if an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.Understand this error
index.html:13 
.....................................................................................
			  Database Integration
.....................................................................................

Express can integrate sql and no sql databases,provided database drivers.

1.Mongodb integration with Mongoose

G:\Marsh\nodejs>mkdir expressMongo

G:\Marsh\nodejs>cd expressMongo
G:\Marsh\nodejs\expressMongo>npm init --yes
Wrote to G:\Marsh\nodejs\expressMongo\package.json:

{
  "name": "expressmongo",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}

2.Install dependencies
npm i express
npm install mongoose --save
npm i nodemon --save-dev
npm i body-parser


Coding:

1.define schema
   plan for your collection
const mongoose = require('mongoose')

const schema = mongoose.schema({
    title:String,
    content:String
})
Datatypes:
1.String
2.Number
3.Date
4.Buffer
5.Boolean
6.Mixed
7.ObjectId
8.Array
9.Decimal128
10.Map
11.UUID


2.create model out of schema
const mongoose = require('mongoose')

const schema = mongoose.schema({
    title:String,
    content:String
})

module.exports=mongoose.model("Post",schema)
.....................................................................................
			 Mongoose Core setup:


1.Create Model

const mongoose = require('mongoose')

//define schema 
const schema = mongoose.Schema({
    title: String,
    content: String
})
//create model and export
module.exports = mongoose.model("Post", schema)

2.Service
src/services/post.service.js
const Post = require('../models/post.model')

class PostService {

    async findAll() {
        return await Post.find()
    }
}
module.exports = new PostService()

3.Router
src/routers/post.router.js
const express = require('express')
const postService = require('../services/post.service')
const postRouter = express.Router()


postRouter.get('/', async (req, res) => {
    try {
        const posts = await postService.findAll()
        return res.json(posts)

    }
    catch (err) {
        res.status(500).json({ err })
    }
})





module.exports = postRouter

4.Main App
src/app.js
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const mongoose = require('mongoose');

app.use(bodyParser.json())

const PORT = 3000

//connect to mongodb
async function connectDb() {
    try {
        await mongoose.connect('mongodb://127.0.0.1:27017/myDb')
        console.log("Mongo is connected")

        // const server = app.listen(PORT, () => {
        //     console.log(server.address())
        //     console.log(`Express is running @ ${server.address().port}`)
        // })

    }
    catch (e) {
        console.log(e)
    }
}
connectDb()

app.use('/api/posts', require('./routers/post.router'))


const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})
.....................................................................................
		  CREATE,UPDATE,DELETE
.....................................................................................


const Post = require('../models/post.model')

class PostService {

    async findAll() {
        return await Post.find()
    }

    async findById(id) {
        const post = await Post.findOne({ _id: id })
        return post
    }
    async save(post) {
        const newPost = new Post({ title: post.title, content: post.content })
        await newPost.save()
        return newPost
    }
    async update(id, post) {
        //get Post document
        const newPost = await Post.findOne({ _id: id })
        if (!newPost) {
            throw Error()
        }
        if (post.title) {
            newPost.title = post.title
        }
        if (post.content) {
            newPost.content = post.content
        }
        await newPost.save()
        return newPost
    }

    async remove(id) {
        const post = await Post.findOne({ _id: id })
        if (post) {
            await Post.deleteOne({ _id: id })
        } else {
            throw Error()
        }
    }
}
module.exports = new PostService()
.....................................................................................
const express = require('express')
const postService = require('../services/post.service')
const postRouter = express.Router()


postRouter.get('/', async (req, res) => {
    try {
        const posts = await postService.findAll()
        return res.json(posts)

    }
    catch (err) {
        res.status(500).json({ err })
    }
})

postRouter.get('/:id', async (req, res) => {
    const id = req.params.id
    try {
        const post = await postService.findById(id)
        if (!post) {
            return res.status(500).json({ message: `Requested Post for  ${id} Not found` })
        }
        return res.status(200).json(post)
    }
    catch (err) {
        res.status(500).json({ err })
    }
})


postRouter.post('/', async (req, res) => {
    const post = req.body
    try {
        const savedPost = await postService.save(post)
        return res.status(201).json(savedPost)
    }
    catch (err) {
        res.status(500).json({ err })
    }
})

postRouter.put('/:id', async (req, res) => {
    const postInput = req.body
    const id = req.params.id
    try {
        const post = await postService.update(id, postInput)
        return res.status(200).json(post)
    }
    catch (err) {
        res.status(500).json({ err })
    }
})

postRouter.delete('/:id', async (req, res) => {
    const id = req.params.id
    try {
        await postService.remove(id)
        res.status(204).send()
    }
    catch (err) {
        res.status(404).json({ err: "Post Does not exit" })
    }
})
module.exports = postRouter
.....................................................................................
		https://mongoosejs.com/docs/queries.html
.....................................................................................




















